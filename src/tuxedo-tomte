#!/usr/bin/perl -w

# Copyright (c) TUXEDO Computers GmbH <tux@tuxedocomputers.com>
# This file is part of TUXEDO Tomte.
#
# TUXEDO Tomte is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TUXEDO Tomte is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with TUXEDO Tomte. If not, see <https://www.gnu.org/licenses/>.

use strict qw(vars subs);
use warnings;
use autodie;
use 5.010;

use Fcntl qw(:DEFAULT :flock :seek :Fcompat);
use File::FcntlLock;

use File::Copy;

# for OLED backlight and edid decrypt
use FindBin qw($Bin);
use lib "$Bin/.";
use Parse::EDID qw(parse_edid);

use Time::HiRes qw(usleep);
use Digest::MD5 qw(md5_hex);

# for debugging
use Data::Dumper;
# logLevel:
# 0 = normal
# 1 = some debug
# 2 = lots of debug
my $logLevel = 2;

# for console language and locale
my $consoleLanguage = 'LANG=C;LANGUAGE=C;';
$ENV{LC_MESSAGES} = 'C';

my $logDir = '/var/log/tomte/';
my $logFile = $logDir.'tomte.log';
my $LOGFILE;

###############################################################################
# Argument values given to script
#
my %argValue = (
	command => '',
	module => '',
);

if (@ARGV > 0) { $argValue{command} = $ARGV[0]; }
if (@ARGV > 1) { $argValue{module} = $ARGV[1]; }

# make sure this is the only running instance
use Fcntl ':flock';
 
my $ME;
open ($ME, '<', $0);
if (!(flock $ME, LOCK_EX|LOCK_NB)) {
	dieSingleton();
}


my $grubFile = '/etc/default/grub';
my $noLogFile = 1;		# 0 = logFile ok, 1 = no logFile
my $noConfigFile = 1;	# 0 = configfile ok, 1 = no configfile
my $configDir = '/etc/tomte/';
my $configFile = $configDir.'tomte.cfg';
my %modeFile = (
	DONT_CONFIGURE => $configDir.'DONT_CONFIGURE',
	UPDATES_ONLY => $configDir.'UPDATES_ONLY',
	AUTOMATIC => $configDir.'AUTOMATIC',
);
my $mode = 'AUTOMATIC'; #default mode
my $shareDir = '/usr/share/tuxedo-tomte/';
my $reposList = $shareDir.'repolist.txt';
my $distribution;
my $distributionVersion;
my $completeDistVersion;
my $FAI = 0;
my $LiveISO = 0;
my $networkSearchDone = 0;
my $triesFile = '/tmp/tomteTries';
my $triesLimit = 3;
my $tomteFinishedFile = '/tmp/tomte_finished';
my $kernelRelease = `uname -r`;
$kernelRelease =~ s/[\n\r]//g;

my $lspciOutput = `lspci -vn`;
my $boardnameFilename = "/sys/class/dmi/id/board_name";
my $boardname;
$boardname = readFileReturnLine($boardnameFilename);

my $boardvendorFilename = "/sys/class/dmi/id/board_vendor";
my $boardvendor;
$boardvendor = readFileReturnLine($boardvendorFilename);

my $sysvendorFilename = "/sys/class/dmi/id/sys_vendor";
my $sysvendor;
$sysvendor = readFileReturnLine($sysvendorFilename);

# for desktop messages
my $sessionID = readFileReturnLine('/proc/sys/kernel/random/boot_id');
$sessionID =~ /(.{7})/;
$sessionID = hex($1);
printLog("sessionID: $sessionID", 'TL2');
my $longInstall = 0;
my $restartSystem = 0;
my $startLaterAgain = 0;


###############################################################################
# initial definition of post configuration modules
#   command		the command to be executed on the system
#   trigger		'1' / 'undef' wether the command should be executed
#   status		'undef' / 'failed' wether the command execution failed
#
my %postConfProgram = (
	updateGrub => {
		command => 'update-grub',
		trigger => 0,
		status => 'undef',
		description => 'reconfigures grub according to grub file',
	},
	updateInitramfs => {
		command => 'update-initramfs -u -k all',
		trigger => 0,
		status => 'undef',
		description => 'updates initramfs',
	},
);



###############################################################################
# files to lock to get package management priority
#
my %lockFiles = (
	aptArchivesLock => {
		filename => '/var/cache/apt/archives/lock',
		FH => '',
		number => '0',
		locked => '0',
	},
	aptListsLock => {
		filename => '/var/lib/apt/lists/lock',
		FH => '',
		number => '0',
		locked => '0',
	},
	dpkgLock => {
		filename => '/var/lib/dpkg/lock',
		FH => '',
		number => '0',
		locked => '0',
	},
	dpkgLockFrontend => {
		filename => '/var/lib/dpkg/lock-frontend',
		FH => '',
		number => '0',
		locked => '0',
	},
);



###############################################################################
# list of supported OS versions
# with repective repo entries
#
# NAME
#     versions
#         VERSION_ID
#             name = VERSION_CODENAME
# 
my %supportedOS = (
	"Ubuntu" => {
		versions => {
			"18.04" => {
				name => 'bionic',
			},
			"20.04" => {
				name => 'focal',
			},
			"22.04" => {
				name => 'jammy',
			},
		},
	},
	"elementary OS" => {
		versions => {
			"6.1" => {
				name => 'jolnir',
			},
		},
	},
	"KDE neon" => {
		versions => {
			"20.04" => {
				name => 'focal',
			},
		},
	},
	"TUXEDO_OS Plasma" => {
		versions => {
			"20.04" => {
				name => 'focal',
			},
			"22.04" => {
				name => 'jammy',
			},
		},
	},
	"TUXEDO OS" => {
		versions => {
			"20.04" => {
				name => 'focal',
			},
			"22.04" => {
				name => 'jammy',
			},
		},
	},
);


my %tuxedo_repos = (
	"Ubuntu 18.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu bionic main'],
		},
		oibaf => {
			filename => '/etc/apt/sources.list.d/oibaf-tuxedo.list',
			content => ['deb https://oibaf.tuxedocomputers.com/ubuntu bionic main'],
		},
		graphics => {
			filename => '/etc/apt/sources.list.d/graphics-tuxedo.list',
			content => ['deb https://graphics.tuxedocomputers.com/ubuntu bionic main'],
		},
		name => 'bionic',
	},
	"Ubuntu 20.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu focal main'],
		},
		oibaf => {
			filename => '/etc/apt/sources.list.d/oibaf-tuxedo.list',
			content => ['deb https://oibaf.tuxedocomputers.com/ubuntu focal main'],
		},
		graphics => {
			filename => '/etc/apt/sources.list.d/graphics-tuxedo.list',
			content => ['deb https://graphics.tuxedocomputers.com/ubuntu focal main'],
		},
		name => 'focal',
	},
	"Ubuntu 22.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu jammy main'],
		},
		name => 'jammy',
	},
	"elementary OS 6.1" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu focal main'],
		},
		oibaf => {
			filename => '/etc/apt/sources.list.d/oibaf-tuxedo.list',
			content => ['deb https://oibaf.tuxedocomputers.com/ubuntu focal main'],
		},
		graphics => {
			filename => '/etc/apt/sources.list.d/graphics-tuxedo.list',
			content => ['deb https://graphics.tuxedocomputers.com/ubuntu focal main'],
		},
		name => '6.1 jolnir',
	},
	"KDE neon 20.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu focal main'],
		},
		oibaf => {
			filename => '/etc/apt/sources.list.d/oibaf-tuxedo.list',
			content => ['deb https://oibaf.tuxedocomputers.com/ubuntu focal main'],
		},
		graphics => {
			filename => '/etc/apt/sources.list.d/graphics-tuxedo.list',
			content => ['deb https://graphics.tuxedocomputers.com/ubuntu focal main'],
		},
		name => 'focal',
	},
	"TUXEDO_OS Plasma 20.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu focal main'],
		},
		oibaf => {
			filename => '/etc/apt/sources.list.d/oibaf-tuxedo.list',
			content => ['deb https://oibaf.tuxedocomputers.com/ubuntu focal main'],
		},
		graphics => {
			filename => '/etc/apt/sources.list.d/graphics-tuxedo.list',
			content => ['deb https://graphics.tuxedocomputers.com/ubuntu focal main'],
		},
		name => 'focal',
	},
	"TUXEDO_OS Plasma 22.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu jammy main'],
		},
		name => 'jammy',
	},
	"TUXEDO OS 20.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu focal main'],
		},
		oibaf => {
			filename => '/etc/apt/sources.list.d/oibaf-tuxedo.list',
			content => ['deb https://oibaf.tuxedocomputers.com/ubuntu focal main'],
		},
		graphics => {
			filename => '/etc/apt/sources.list.d/graphics-tuxedo.list',
			content => ['deb https://graphics.tuxedocomputers.com/ubuntu focal main'],
		},
		name => 'focal',
	},
	"TUXEDO OS 22.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb https://deb.tuxedocomputers.com/ubuntu jammy main'],
		},
		name => 'jammy',
	},


);



my %tuxedo_mirrors = (
	"Ubuntu 18.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu bionic main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu bionic-security main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu bionic-updates main restricted universe multiverse'],
		},
		name => 'bionic',
	},
	"Ubuntu 20.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu focal-security main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse'],
		},
		name => 'focal',
	},
	"Ubuntu 22.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu jammy-security main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse'],
		},
		name => 'jammy',
	},
	"elementary OS 6.1" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb http://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal main restricted universe multiverse',
						'deb http://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu focal-security main restricted universe multiverse',
						'deb http://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse'],
		},
		name => '6.1 jolnir',
	},
	"KDE neon 20.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu focal-security main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse'],
		},
		name => 'focal',
	},
	"TUXEDO_OS Plasma 20.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu focal-security main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse'],
		},
		name => 'focal',
	},
	"TUXEDO_OS Plasma 22.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu jammy-security main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse'],
		},
		name => 'jammy',
	},
	"TUXEDO OS 20.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu focal-security main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse'],
		},
		name => 'focal',
	},
	"TUXEDO OS 22.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu jammy-security main restricted universe multiverse',
						'deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse'],
		},
		name => 'jammy',
	},

);



my %flavours = (
	"18.04" => {
		"linux-generic" => {
			installPackages => 'linux-generic linux-headers-generic linux-image-generic',
		},
		"linux-generic-hwe-18.04" => {
			installPackages => 'linux-generic-hwe-18.04 linux-headers-generic-hwe-18.04 linux-image-generic-hwe-18.04',
		},
		"linux-generic-hwe-18.04-edge" => {
			installPackages => 'linux-generic-hwe-18.04-edge linux-headers-generic-hwe-18.04-edge linux-image-generic-hwe-18.04-edge',
		},
	},
	"20.04" => {
		"linux-generic" => {
			installPackages => 'linux-generic linux-headers-generic linux-image-generic',
		},
		"linux-oem-20.04" => {
			installPackages => 'linux-oem-20.04 linux-oem-20.04b linux-headers-oem-20.04b linux-image-oem-20.04b',
		},
		"linux-oem-20.04-edge" => {
			installPackages => 'linux-oem-20.04-edge linux-oem-20.04b linux-headers-oem-20.04b linux-image-oem-20.04b',
		},
		"linux-generic-hwe-20.04" => {
			installPackages => 'linux-generic-hwe-20.04 linux-headers-generic-hwe-20.04 linux-image-generic-hwe-20.04',
		},
		"linux-generic-hwe-20.04-edge" => {
			installPackages => 'linux-generic-hwe-20.04-edge linux-headers-generic-hwe-20.04-edge linux-image-generic-hwe-20.04-edge',
		},
		"linux-tuxedo-20.04-edge" => {
			installPackages => 'linux-tuxedo-20.04-edge linux-headers-tuxedo-20.04-edge linux-image-tuxedo-20.04-edge',
		},
		"linux-tuxedo-20.04" => {
			installPackages => 'linux-tuxedo-20.04 linux-headers-tuxedo-20.04 linux-image-tuxedo-20.04',
		},
		"linux-tuxedo-20.04-next" => {
			installPackages => 'linux-tuxedo-20.04-next linux-headers-tuxedo-20.04-next linux-image-tuxedo-20.04-next',
		},
	},
	"22.04" => {
		"linux-generic" => {
			installPackages => 'linux-generic linux-headers-generic linux-image-generic',
		},
		"linux-aws" => {
			installPackages => 'linux-aws linux-headers-aws linux-image-aws',
		},
		"linux-tuxedo-22.04" => {
			installPackages => 'linux-tuxedo-22.04 linux-headers-tuxedo-22.04 linux-image-tuxedo-22.04',
		},
	},
	"6.1" => {
		"linux-generic" => {
			installPackages => 'linux-generic linux-headers-generic linux-image-generic',
		},
		"linux-oem-20.04" => {
			installPackages => 'linux-oem-20.04 linux-oem-20.04b linux-headers-oem-20.04b linux-image-oem-20.04b',
		},
		"linux-oem-20.04-edge" => {
			installPackages => 'linux-oem-20.04-edge linux-oem-20.04b linux-headers-oem-20.04b linux-image-oem-20.04b',
		},
		"linux-generic-hwe-20.04" => {
			installPackages => 'linux-generic-hwe-20.04 linux-headers-generic-hwe-20.04 linux-image-generic-hwe-20.04',
		},
		"linux-generic-hwe-20.04-edge" => {
			installPackages => 'linux-generic-hwe-20.04-edge linux-headers-generic-hwe-20.04-edge linux-image-generic-hwe-20.04-edge',
		},
		"linux-tuxedo-20.04-edge" => {
			installPackages => 'linux-tuxedo-20.04-edge linux-headers-tuxedo-20.04-edge linux-image-tuxedo-20.04-edge',
		},
		"linux-tuxedo-20.04" => {
			installPackages => 'linux-tuxedo-20.04 linux-headers-tuxedo-20.04 linux-image-tuxedo-20.04',
		},
		"linux-tuxedo-20.04-next" => {
			installPackages => 'linux-tuxedo-20.04-next linux-headers-tuxedo-20.04-next linux-image-tuxedo-20.04-next',
		},
	},

);



###############################################################################
#
# Each device has
# - a unique ID
# - one or more model names (array)
# - one or more board names (array)
# - the fixes that apply (array)
# - which Ubuntu flavours (array)
# - PCI device (if available, regex)
# - CPU (if needed)
# - Kernel (if needed, regex)
# - display (if needed, as array)
# - USB device (if needed)
# default kernels tuxedokernel2004 and tuxeookernel2204 are not listed
# only kernels that deviate from the default are listed
my %tuxedo_devices = (
	'1' => {
		model => ['TUXEDO Aura 15 Gen1'],
		board_name => ['NL5xRU', 'AURA1501'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:a500',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'2' => {
		model => ['TUXEDO Book BA15 Gen1'],
		board_name => ['PF5PU1G'],
		fix => ['nobootonbattery', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'3' => {
		model => ['TUXEDO Book BC15 Gen10', 'TUXEDO Book BC17 Gen10'],
		board_name => ['NHxxRZQ'],
		fix => ['r8168dkms'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:8562',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'4' => {
		model => ['TUXEDO Book BX1507'],
		board_name => ['N350TW'],
		fix => ['tuxedorestoreaudiofix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'5' => {
		model => ['TUXEDO Book DX1508', 'TUXEDO Book DX1708'],
		board_name => ['N8xEJEK'],
		fix => ['backlightfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'AUO Model 12701 Serial Number 585803690',
		usb_device => '',
	},
	'6' => {
		model => ['TUXEDO Book XA15 Gen10'],
		board_name => ['NH5xAx'],
		fix => ['nokeyboardaftersuspendfix', 'corefix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:50f0',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'7' => {
		model => ['TUXEDO Book XC15 Gen10', 'TUXEDO Book XC17 Gen10'],
		board_name => ['PB50_70DFx,DDx'],
		fix => ['nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:67e1',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'8' => {
		model => ['TUXEDO Book XP15 Gen12', 'TUXEDO Book XP17 Gen12'],
		board_name => ['PCx0Dx_GN20'],
		fix => ['tuxedokeyboardite'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => ['1558:65e5', '1558:67e5'],
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'9' => {
		model => ['TUXEDO Book XUX7 Gen11'],
		board_name => ['X170SM'],
		fix => ['nokeyboardaftersuspendfix', 'tuxedokeyboardite'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'10' => {
		model => ['TUXEDO Book XUX7 Gen13'],
		board_name => ['X170KM-G'],
		fix => ['tuxedokeyboardite', 'kerneltuxedo2004edge', 'nokeyboardaftersuspendfix', 'thunderboltbootdelayfix'],
		flavour => ['20.04', '22.04'],
		pci_id => '1558:7715',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'11' => {
		model => ['TUXEDO EduBook 15 Gen2'],
		board_name => ['EDUBOOK1502'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'12' => {
		model => ['TUXEDO InfinityBook 14 v2'],
		board_name => ['X35R'],
		fix => ['elantechtouchpadfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'13' => {
		model => ['TUXEDO InfinityBook Pro 14 Gen6'],
		board_name => ['PHxTQx1', 'PHxTxX1', 'PH4TQx1'],
		fix => ['lightdmlogindcheckgraphicalfix', 'tuxedotouchpadswitch', 'i915enablepsrfix', 'kerneltuxedo2004edge', 'earlyloadbacklightcontrolfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1d05:1132',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'14' => {
		model => ['TUXEDO InfinityBook Pro 14 v5'],
		board_name => ['N141CU'],
		fix => ['nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'15' => {
		model => ['TUXEDO InfinityBook Pro 15 v5'],
		board_name => ['N150CU'],
		fix => ['nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:1404',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'17' => {
		model => ['TUXEDO Polaris Gen1 AMD NVIDIA GTX1650Ti'],
		board_name => ['POLARIS1501A1650TI', 'POLARIS1701A1650TI'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'amdgpuwithnvidiafix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'18' => {
		model => ['TUXEDO Polaris Gen1 AMD NVIDIA RTX2060'],
		board_name => ['POLARIS1501A2060', 'POLARIS1701A2060'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'amdgpuwithnvidiafix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'19' => {
		model => ['TUXEDO Polaris Gen1 Intel NVIDIA GTX1650Ti'],
		board_name => ['POLARIS1501I1650TI', 'POLARIS1701I1650TI'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'20' => {
		model => ['TUXEDO Polaris Gen1 Intel NVIDIA RTX2060'],
		board_name => ['POLARIS1501I2060', 'POLARIS1701I2060'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'21' => {
		model => ['TUXEDO Pulse 14 Gen1'],
		board_name => ['PULSE1401'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'22' => {
		model => ['TUXEDO Pulse 15 Gen1'],
		board_name => ['PULSE1501'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'23' => {
		model => ['TUXEDO Stellaris Gen2 AMD', 'TUXEDO Polaris Gen2 AMD'],
		board_name => ['GMxNGxx'],
		fix => ['tuxedotouchpadswitch', 'amdgpubacklightauxoff'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'BOE Model 2423 Serial Number 0',
		usb_device => '',
	},
	'24' => {
		model => ['TUXEDO Stellaris Gen2 Intel', 'TUXEDO Polaris Gen2 Intel'],
		board_name => ['GMxMGxx'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'25' => {
		model => ['TUXEDO Stellaris Gen3 AMD', 'TUXEDO Polaris Gen3 AMD'],
		board_name => ['GMxZGxx'],
		fix => ['tuxedotouchpadswitch', 'tuxedokeyboardite', 'amdgpubacklightauxoff', 'kerneltuxedo2004next'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => ['BOE Model 2423 Serial Number 0', 'BOE Model 2420 Serial Number 0'],
		usb_device => '',
	},
	'26' => {
		model => ['TUXEDO Stellaris Gen3 Intel', 'TUXEDO Polaris Gen3 Intel'],
		board_name => ['GMxTGxx'],
		fix => ['tuxedotouchpadswitch', 'tuxedokeyboardite', 'nvidiabacklightcontrolfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'27' => {
		model => ['TUXEDO Trinity Gen1 Intel'],
		board_name => ['TRINITY1501I', 'TRINITY1701I'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'28' => {
		model => ['XMG Fusion 15 L19 GTX1660Ti'],
		board_name => ['LAPQC71A'],
		fix => ['nokeyboardaftersuspendfix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'29' => {
		model => ['XMG Fusion 15 L19 RTX2070'],
		board_name => ['LAPQC71B'],
		fix => ['nokeyboardaftersuspendfix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'30' => {
		model => ['all models'],
		board_name => [''],
		fix => ['apportfix', 'tuxedorepos', 'tuxedomirrors'],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'32' => {
		model => ['all with fingerprintreader'],
		board_name => [''],
		fix => ['fingerprintreader'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => ['147e:100[0123]', '147e:20(15|16|20)', '147e:300[01]', '147e:500[23]', '0483:201[56]', '1c7a:0603'],
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'33' => {
		model => ['all with LTE module ME936'],
		board_name => [''],
		fix => ['threegfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '12d1:15bb',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => 'ME936',
	},
	'34' => {
		model => ['all with NVIDIA'],
		board_name => [''],
		fix => ['nvidiadriver'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '030[02]:',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'35' => {
		model => ['all with OLED display'],
		board_name => [''],
		fix => ['tuxedooledbrt'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'SDC Model 41001 Serial Number 0',
		usb_device => '',
	},
	'36' => {
		model => ['Kinston NVMe'],
		board_name => [''],
		fix => ['tuxedonvmefix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '2646:2263',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'37' => {
		model => ['InfinityBook S 17 Gen6', 'InfinityBook S 15 Gen6'],
		board_name => ['NS50_70MU', 'NS50MU'],
		fix => ['i8042noauxfix'],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'38' => {
		model => ['TUXEDO Book XP14 Gen12'],
		board_name => ['NV4XMB,ME,MZ'],
		fix => ['lightdmlogindcheckgraphicalfix', 'earlyloadbacklightcontrolfix'],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'39' => {
		model => ['TUXEDO Aura 15 Gen2'],
		board_name => ['NL5xNU'],
		fix => [],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'40' => {
		model => ['all models'],
		board_name => [''],
		fix => ['apportfix', 'tuxedorepos', 'tuxedomirrors'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'41' => {
		model => ['TUXEDO Stellaris Gen4 Intel'],
		board_name => ['GMxAGxx'],
		fix => ['tuxedokeyboardite', "tuxedotouchpadswitch"],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'42' => {
		model => ['all with LTE module ME906s'],
		board_name => [''],
		fix => ['threegfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '12d1:15c1',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => 'ME906',
	},
	'43' => {
		model => ['all with cardreader Realtek RTS522A'],
		board_name => [''],
		fix => ['cardreaderfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => ['10ec:522a'],
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'44' => {
		model => ['all with Realtek RTL8125'],
		board_name => [''],
		fix => ['rtl8125dkms'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '10ec:8125',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'45' => {
		model => ['TUXEDO Pulse 15 Gen2'],
		board_name => ['PF5LUXG'],
		fix => ['tuxedotouchpadswitch', 'samsungnvmefix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'46' => {
		model => ['TUXEDO InsanityBook 15 v1'],
		board_name => ['P95_HP', 'P95_HR', 'P95_HP,HR,HQ'],
		fix => ['backlightfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'AUO Model 21229 Serial Number 808797180',
		usb_device => '',
	},
	'47' => {
		model => ['XP1507'],
		board_name => ['P95_HP', 'P95_HR', 'P95_HP,HR,HQ'],
		fix => ['backlightfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'AUO Model 21229 Serial Number 808797180',
		usb_device => '',
	},
	'48' => {
		model => ['TUXEDO Stellaris Gen4 AMD'],
		board_name => ['GMxRGxx'],
		fix => ['tuxedokeyboardite', "tuxedotouchpadswitch"],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
);



###############################################################################
#
# For each new module add an entry into:
# - %origConfModules
# - checkRequirements()
# - the section with all the modules subroutines

# For changes in %origConfModules make the modifications also in:
# - writeConfigFile()

###############################################################################
# initial definition for all origConfModules/packages
# defined by a 'short name' which is the name without '-'
# e.g. no-boot-on-battery = nobootonbattery
#
#   name			name of package or name of solution
#   version			the package or solution version
#					rises if the solution changes
#   installed		'no' not installed / 'yes' installed / 'failed' failed to
#					install, 'undef' if unknown
#   blocked			'yes' or 'no' will not be configured on upgrade, install
#					or deinstall, 'undef' if unknown
#   required		'yes' or 'no' the system requirements are met
#					'undef' if unknown
#					'prerequisite' if essentially needed to be present before
#					anything else and always, non blockable
#   hwid			the environment (HW or SW) are in a certain defined state
#					rises if additional HW gets support
#   package			'yes' or 'no', there is a deb or rpm package as a solution
#   				if there are seceral packages to be installed then 'no'
#   fainame			the name to give to FAI to install a certain package
#   description		A description about the module for the user
#   postconf		command module to execute after installation of module,
#					empty if none, the command of the module is defined in
#					$postConfModule{$postconf}{command}
#	upgrade			if the system determines this is an upgrade then 'yes'
#					else 'no'
#					don't set the value yourself, it will be determined by
#					Tomte
#	upgraded		if module was upgraded 'yes', else 'no'
#	reconfigure		if set to 'always' will always reconfigure if fix detected
#	restart			the system requires a restart after this module was
#					installed or upgraded
#	order			'first': has to be installed before anything else
#					'last': has to be installed after anything else
#
my %origConfModules = (
	i8042fix => {
		name => 'i8042-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fix for no-keyboard-present after boot on XC1711',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	nobootonbattery => {
		name => 'no-boot-on-battery',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fix for no-boot-on-battery on BA15',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	amdxhcihcdusbquirksuspendfix => {
		name => 'amd-xhci-hcd-usb-quirk-suspend-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Fix for some AMD devices where the xhci_hcd driver causes a jump out of suspend immediately on entering suspend',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	amdgpuwithnvidiafix => {
		name => 'amd-gpu-with-nvidia-fix',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Enables activation of discrete NVIDIA graphics on devices with built-in AMD graphics. Also enables switching between both with prime-select',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	tuxedocontrolcenter => {
		name => 'tuxedo-control-center',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'TUXEDO Control Center Application',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	tuxedokeyboard => {
		name => 'tuxedo-keyboard',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Keyboard & keyboard backlight driver for TUXEDO notebooks',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	nokeyboardaftersuspendfix => {
		name => 'no-keyboard-after-suspend-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 5,
		package => 'no',
		fainame => '',
		description => 'Fixes no keyboard after suspend problem',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	backlightfix => {
		name => 'backlight-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Fixes backlight issues for DX1708, GTX1060 with AUO Model 12701 and 21229 displays',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	tuxedorepos => {
		name => 'tuxedo-repos',
		version => 3,
		installed => 'no',
		blocked => 'no',
		required => 'prerequisite',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Prerequisite! Adds the TUXEDO repositories',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => '',
		order => 'first',
	},
	tuxedomirrors => {
		name => 'tuxedo-mirrors',
		version => 4,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Adds TUXEDO maintained Ubuntu repositories',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => '',
		order => 'first',
	},
	corefix => {
		name => 'core-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'ACPI mod for accurate cores recognition',
		postconf => 'updateInitramfs',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	threegfix => {
		name => 'threeg-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Configuration needed to operate Huawei-ME936',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	threegfix2 => {
		name => 'threeg-fix2',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Configuration needed to operate Huawei-ME906s',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},

	elantechtouchpadfix => {
		name => 'elantech-touchpad-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fixes non working Elantech touchpad',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	tuxedotouchpadswitch => {
		name => 'tuxedo-touchpad-switch',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Adds hardware enable/disable for touchpads with LED indicator on several TUXEDO notebooks',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	tuxedonvmefix => {
		name => 'tuxedo-nvme-fix',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Removes sleep bug on Kingston A2000 NVME devices by updating the firmware',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	tuxedokeyboardite => {
		name => 'tuxedo-keyboard-ite',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'yes',
		fainame => '',
		description => 'Keyboard back-light driver for ITE devices',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	fingerprintreader => {
		name => 'fingerprint-reader',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Packages needed for fingerprint reader to work on certain TUXEDO notebooks',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	mesautils => {
		name => 'mesa-utils',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'The Mesa 3D Graphics Library',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	tuxedorestoreaudiofix => {
		name => 'tuxedo-restore-audio-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Systemd service which rescans for missing audio devices',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	kerneltuxedo2004edge => {
		name => 'linux-tuxedo-20.04-edge',
		version => 3,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Required kernel version linux-tuxedo-20.04-edge',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	kerneltuxedo2004next => {
		name => 'linux-tuxedo-20.04-next',
		version => 3,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Required kernel version linux-tuxedo-20.04-next',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	kerneltuxedo2004 => {
		name => 'linux-tuxedo-20.04',
		version => 3,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Required kernel version linux-tuxedo-20.04',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	kernelgenerichwe2004 => {
		name => 'linux-generic-hwe-20.04',
		version => 3,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Required kernel version linux-generic-hwe-20.04',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	kernelgenerichwe2004edge => {
		name => 'linux-generic-hwe-20.04-edge',
		version => 3,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Required kernel version linux-generic-hwe-20.04-edge',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	kerneltuxedo2204 => {
		name => 'linux-tuxedo-22.04',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Required kernel version linux-tuxedo-22.04',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	nvidiadriver => {
		name => 'nvidia-driver',
		version => 3,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Required Nvidia drivers',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	cracklibruntime => {
		name => 'cracklib-runtime',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Builds password dictionary databases',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	# deprecated since 20220216
	amdgpudkms => {
		name => 'amdgpu-dkms',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 3,
		package => 'yes',
		fainame => '',
		description => 'Enables AMD GPU and display to share configuration information',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	r8168dkms => {
		name => 'r8168-dkms',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Linux device driver for several Realtek Ethernet controllers',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	tuxedooledbrt => {
		name => 'tuxedo-oled-brt',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Workaround to control OLED display brightness using dbus and xrandr',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	apportfix => {
		name => 'apport-fix',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Workaround for undefined problems with apport',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	# deprecated since 20220215
	realtekr8125dkms => {
		name => 'realtek-r8125-dkms',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Linux device driver for several Realtek Ethernet controllers [obsolete]',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
		order => '',
	},
	amdgpubacklightauxoff => {
		name => 'amdgpu-backlight-aux-off',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fixes backlight control',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	i915disablepsrfix => {
		name => 'i915-disable-psr-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Fixes screen flickering when using some input devices',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	i915enablepsrfix => {
		name => 'i915-enable-psr-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 3,
		package => 'no',
		fainame => '',
		description => 'Provides better battery life',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	tuxedopinfixtgldkms => {
		name => 'tuxedo-pinfix-tgl-dkms',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Fixes unresponsive touchpad',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	tuxedomicfix1 => {
		name => 'tuxedo-micfix1',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'yes',
		fainame => '',
		description => 'Kernel audio module which fixes different issues with audio output',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	thunderboltbootdelayfix => {
		name => 'thunderbolt-boot-delay-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Solves kernel takes too long at loading thundebolt module at boot',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	i8042noauxfix => {
		name => 'i8042noaux-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fix for touchpad related issues',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	lightdmlogindcheckgraphicalfix => {
		name => 'lightdm-logind-check-graphical-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fixes lightdm starting before windowmanager',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'no',
		order => '',
	},
	nvidiabacklightcontrolfix => {
		name => 'nvidia-backlight-control-fix',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fixes backlight control for Nvidia GPUs',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	earlyloadbacklightcontrolfix => {
		name => 'early-load-backlight-control-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'For backlight control working with Nvidia, the i915 needs to be loaded earlier',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
		order => '',
	},
	r8125dkms => {
		name => 'r8125-dkms',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Newest driver for RTL8125 2.5GbE Controller, fixes ethernet bug',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	cardreaderfix => {
		name => 'cardreader-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'udev rule which inhibits power idle state for cardreader RTS522A',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
	samsungnvmefix => {
		name => 'samsung-nvme-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'fix for Samsung NVMe wake up from sleep',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
		order => '',
	},
);



###############################################################################
# simple print out of all supported devices and fixes
#
sub printTuxedoDevices {
	my $ID;
	foreach $ID (keys %tuxedo_devices) {
		if ((defined $tuxedo_devices{$ID}) && ($tuxedo_devices{$ID} ne '') && (exists $tuxedo_devices{$ID})) {
			printIfExistsNotUndefinedNotEmpty("$ID", "model");
			printIfExistsNotUndefinedNotEmpty("$ID", "board_name");
			printIfExistsNotUndefinedNotEmpty("$ID", "fix");
			printIfExistsNotUndefinedNotEmpty("$ID", "flavour");
			printIfExistsNotUndefinedNotEmpty("$ID", "pci_id");
			printIfExistsNotUndefinedNotEmpty("$ID", "cpu");
			printIfExistsNotUndefinedNotEmpty("$ID", "kernel");
			printIfExistsNotUndefinedNotEmpty("$ID", "display");
			printIfExistsNotUndefinedNotEmpty("$ID", "usb_device");
		}
	}
}


sub printIfExistsNotUndefinedNotEmpty {
	my $ID = shift;
	my $type = shift;
	if ((defined $tuxedo_devices{$ID}{$type}) && ($tuxedo_devices{$ID}{$type} ne '') && (exists $tuxedo_devices{$ID}{$type})) {
		if (ref($tuxedo_devices{$ID}{$type}) eq 'ARRAY') {
			if ($tuxedo_devices{$ID}{$type}->[0] ne '') {
				my $joinedArray = join ' ', @{$tuxedo_devices{$ID}{$type}};
				print "$type: $joinedArray\n";
			}
		} else {
			print "$type: $tuxedo_devices{$ID}{$type}\n";
		}
	}
}



# hash to load the configfile
# is a copy from origConfModules to exclude undefined values
my %localConfModules = %origConfModules;


# empty hash, will be filled with successfully installed modules
# as hashes: {modulename}{status}
# where status should be "success" or "failed"
#
my %configuredModules;


###############################################################################
# die if another instance is running
#
sub dieSingleton {
	print "Another instance is already running, please wait till it is finished\n";
	exit (1);
}



###############################################################################
# lock a file: acquireLock(filename)
# returns the filehandle and a number if successfull
# returns 0 if failed
#
sub acquireLock {
	my $key = shift;
	my $filename = $lockFiles{$key}{filename};
	my $FH;
	my $fs;
	my $num;
	if (sysopen($FH, $filename, O_RDWR | O_CREAT)) {
		$FH->autoflush(1);
		printLog("acquiring lock: $filename", 'L2');
		$fs = new File::FcntlLock;
		$fs->l_type( F_WRLCK );
		$fs->l_whence( SEEK_SET );
		$fs->l_start( 0 );
		if ($fs->lock( $FH, F_SETLKW )) {
			printLog("locking successfull", 'L2');
			$num = <$FH> || 0;
			$lockFiles{$key}{'FH'} = $FH;
			$lockFiles{$key}{'number'} = $num;
			$lockFiles{$key}{'locked'} = 1;
			return (1);
		} else {
			$lockFiles{$key}{'locked'} = 0;
			printLog("failed to get write lock: $filename: $fs->error", 'L2');
			return (0);
		}
	} else {
		printLog("failed to open: $filename: $!", 'L2');
		return (0);
	}
}

###############################################################################
# release lock: releaseLock(hashkey)
# returns 1 if successfull
# returns 0 if failed
#
sub releaseLock {
	my $key = shift;
	my $filename = $lockFiles{$key}{filename};
	my $FH = $lockFiles{$key}{FH};
	my $num = $lockFiles{$key}{number};
	my $fs;
	if (seek($FH, 0, SEEK_SET)) {
		if (print $FH "$num\n") {
			if (truncate($FH, tell($FH))) {
				$fs = new File::FcntlLock;
				$fs->l_type(F_UNLCK);
				if ($fs->lock( $FH, F_SETLK )) {
					if (close($FH)) {
						$lockFiles{$key}{'locked'} = 0;
						return (1);
					} else {
						printLog("close failed: $filename: $!", 'L0');
						return (0);
					}
				} else {
					printLog("unlock failed: $filename: $fs->error", 'L0');
					return (0);
				}
			} else {
				printLog("truncate failed: $filename: $!", 'L0');
				return (0);
			}
		} else {
			printLog("write failed: $filename: $!", 'L0');
			return (0);
		}
	} else {
		printLog("seek failed: $filename: $!", 'L0');
		return (0);
	}
}

###############################################################################
# lock all files for package management
# does nothing if in FAI
#
sub lockPackageManagement {
	my $key;
	if ($FAI) {
		return (1);
	}
	foreach $key (keys %lockFiles) {
		if (acquireLock($key)) {
			printLog("locked filename: $lockFiles{$key}{filename} filehandle: $lockFiles{$key}{'FH'} number: $lockFiles{$key}{'number'}", 'L2');
		} else {
			printLog("locking $lockFiles{$key}{filename} failed", 'L2');
		}
	}
	printLog("finished locking all files", 'L2');
}




###############################################################################
# unlock all files for package management: unlockPackageManagement(reason)
# reason is just a text string
# does nothing if in FAI
#
sub unlockPackageManagement {
	my $reason = shift;
	my $key;
	my $returnValue = 0;
	if ($FAI) {
		return (1);
	}
	foreach $key (keys %lockFiles) {
		if ($lockFiles{$key}{locked}) {
			$returnValue += releaseLock($key);
		} else {
			printLog("$key undefined lock status", 'L2');
		}
	}
	printLog("finished unlock all files for >$reason<: $returnValue", 'L2');
	return ($returnValue);
}


###############################################################################
# reads a file and returns an array with the lines
# chomps the linefeed
# returns undef if file can't be opened
#
sub readFileReturnLines {
	my $file = shift;
	my $FH;
	my @lines;
	if ( (-e $file) && open($FH, "<", $file) ) {
		chomp(@lines = <$FH>);
		close $FH;
	} else {
		printLog("Err: $!", 'L0');
		printLog("no $file present or unable to open the file for reading", 'L0');
		return;
	}
	return @lines;
}



###############################################################################
# reads a file and returns a line
# chomps the line
# returns undef if file can't be opened
#
sub readFileReturnLine {
	my $file = shift;
	my $FH;
	my $line;
	if ( (-e $file) && open($FH, "<", $file) ) {
		chomp($line = <$FH>);
		close $FH;
	} else {
		printLog("Err: $!", 'L0');
		printLog("no $file present or unable to open the file for reading", 'L0');
		return;
	}
	return $line;
}




###############################################################################
# write a file with (text, filename)
# returns 0 if file could not be written
# returns 1 if file could be written
#
sub writeFile {
	my $text = shift;
	my $file = shift;
	open(FH, '>', $file) or return (0);
	print FH $text;
	close(FH);
	return (1);
}



###############################################################################
# find OS name and version and put them into $distribution and
# $distributionVersion
#
sub readOSData {
	my $osReleaseFile = '/etc/os-release';
	my @osReleaseLines;

	@osReleaseLines = readFileReturnLines($osReleaseFile);

	if ( !@osReleaseLines ) {
		print "Can't determine the operating system\n";
		exit (0);
	}
	foreach ( @osReleaseLines ) {
		if ( $_ =~ /^NAME=/ ) {
			$_ =~ /NAME=\"(.*)\"/;
			$distribution = $1;
		}
		if ( $_ =~ /^VERSION_ID=/ ) {
			$_ =~ /VERSION_ID=\"(.*)\"/;
			$distributionVersion = $1;
		}
	}
	$completeDistVersion = $distribution.' '.$distributionVersion;
}




###############################################################################
# returns the brand of the CPU (AMD or Intel)
# returns undef if no file was found
#
sub cpuBrand {
	my $infos;
	my $cpuinfo = '/proc/cpuinfo';
	if ( (-e $cpuinfo) && open(FH, '<', '/proc/cpuinfo') ) {
		local $/;
		$infos = <FH>;
		close FH;
		if ($infos =~ /vendor_id\s*:\s*AuthenticAMD/) {
			return ('AMD');
		}
	} else {
		printLog("file $cpuinfo was not found", 'L0');
	}
	return ('Intel');
}



###############################################################################
# checks the list of supported distributions and versions and returns
# 1 if supported
# 0 if not
#
sub isOSSupported {
	if (($distribution =~ /elementary OS/) && ($distributionVersion < 6.1)) {
		printLog("this version of elementary OS is not supported, please make an update", 'TL0');
		messageDesktop('this version of elementary OS is not supported, please make an update','this version of elementary OS is not supported, please make an update', 2, 'dialog-warning');
		return (0);
	}
	if (exists($supportedOS{$distribution}{versions}{$distributionVersion})) {
		return (1);
	}
	printLog("This OS is not supported", 'TL0');
	printLog("distribution: >$distribution<", 'TL1');
	printLog("version: >$distributionVersion<", 'TL1');
	return (0);
}


###############################################################################
# check basic requirements the system should fullfill and
# install missing parts
#
sub prerequisites {
	my $module;
	foreach $module (sort keys %origConfModules) {
		# basically only for the required repos
		if (($origConfModules{$module}{order} eq 'first') &&
			($origConfModules{$module}{blocked} eq 'no')) {
			reconfigureSingleModule($origConfModules{$module}{name});
		}
	}
	unlockPackageManagement('pkcon refresh');
	my $output = `pkcon refresh`;
	lockPackageManagement();
	printLog("return from pkcon refresh: $output", 'L2');
}

sub prerequisitesFAI {
	my $output = `apt-get update`;
	printLog("return from apt-get update: $output", 'T2');
}

sub postrequisitesFAI {
	if (httpToHttps(\%tuxedo_repos)) {
		printLog('TUXEDO debian repos set to https', 'L0');
	}
	if (httpToHttps(\%tuxedo_mirrors)) {
		printLog('mirror repos set to https', 'L0');
	}
	# assuming the repos from FAI are all correct
	#reconfigureSingleModule('tuxedo-repos');
	#reconfigureSingleModule('tuxedo-mirrors');
	my $output = `apt-get update`;
	printLog("return from apt-get update: $output", 'T2');
}



###############################################################################
# check whether the module is required for the system
# checks only for hardware
#
sub checkRequirements {
	my $FH;
	my $biosVersion;
	my $lsusb;

	# check values for each module
	if (($boardname =~ /NS50_70MU/) ||
		($boardname =~ /NS50MU/)) {
		$origConfModules{i8042noauxfix}{required} = 'yes';
		printLog('detected i8042.noaux-fix issue', 'L1');
	}

	if ($boardname =~ /PF5PU1G/) {
		$origConfModules{nobootonbattery}{required} = 'yes';
		printLog('detected no-boot-on-battery issue', 'L1');
	}

	if (($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/) ||
		($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /PULSE1401/) ||
		($boardname =~ /PULSE1501/) ||
		($boardname =~ /NL5xRU/) ||
		($boardname =~ /EDUBOOK1502/) ||
  		($boardname =~ /AURA1501/)) {
		$origConfModules{amdxhcihcdusbquirksuspendfix}{required} = 'yes';
		printLog('detected amd-xhci-hcd-usb-quirk-suspend-fix issue', 'L1');
	}

	if (($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/)) {
		if ($distributionVersion =~ /18.04/) {
			$origConfModules{amdgpuwithnvidiafix}{required} = 'yes';
			printLog('detected amd-gpu-with-nvidia-fix issue', 'L1');
		}
	}

	if (($boardname =~ /X170SM/) ||
		($boardname =~ /PB50_70DFx,DDx/) ||
   		($boardname =~ /LAPQC71A/) ||
		($boardname =~ /LAPQC71B/) ||
		($boardname =~ /N141CU/) ||
		($boardname =~ /N150CU/) ||
   		($boardname =~ /NH5xAx/) ||
   		($boardname =~ /NL5xRU/) ||
		($boardname =~ /AURA1501/) ||
		($boardname =~ /EDUBOOK1502/) ||
		($boardname =~ /NS50MU/) ||
		($boardname =~ /NS50_70MU/) ||
		($boardname =~ /NJ50_70CU/) ||
		($boardname =~ /X170KM-G/ )) {
		$origConfModules{nokeyboardaftersuspendfix}{required} = 'yes';
		printLog('detected no-keyboard-after-suspend-fix issue', 'L1');
	}

	if ($boardname =~ /X35R/) {
		$origConfModules{elantechtouchpadfix}{required} = 'yes';
		printLog('detected elantech-touchpad-fix issue', 'L1');
	}

	if (($boardname =~ /LAPQC71A/) ||
		($boardname =~ /LAPQC71B/) ||
		($boardname =~ /PF5PU1G/) ||
		($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/) ||
		($boardname =~ /POLARIS1501I1650TI/) ||
		($boardname =~ /POLARIS1501I2060/) ||
		($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /POLARIS1701I1650TI/) ||
		($boardname =~ /POLARIS1701I2060/) ||
		($boardname =~ /PULSE1401/) ||
		($boardname =~ /PULSE1501/) ||
		($boardname =~ /TRINITY1501I/) ||
		($boardname =~ /TRINITY1701I/) ||
		($boardname =~ /PHxTxX1/) ||
		($boardname =~ /PH4TQx1/) ||
		($boardname =~ /PHxTQx1/) || #alias to PH4TQx1
		($boardname =~ /GMxNGxx/) ||
		($boardname =~ /GMxZGxx/) ||
		($boardname =~ /GMxTGxx/) ||
		($boardname =~ /GMxAGxx/) ||
		($boardname =~ /GMxMGxx/) ||
		($boardname =~ /GMxRGxx/) ||
		($boardname =~ /PF5LUXG/))
	{
		$origConfModules{tuxedotouchpadswitch}{required} = 'yes';
		printLog('detected tuxedo-touchpad-switch issue', 'L1');
	}

	if ($boardname =~ /N8xEJEK/) {
		if (isDisplayPresent("AUO Model 12701 Serial Number 585803690")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog('detected backlight-fix issue', 'L1');
		}
	}
	if ($boardname =~ /P95_HP/) {
		if (isDisplayPresent("AUO Model 21229 Serial Number 808797180")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog('detected backlight-fix issue', 'L1');
		}
	}
	if ($boardname =~ /P95_HR/) {
		if (isDisplayPresent("AUO Model 21229 Serial Number 808797180")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog('detected backlight-fix issue', 'L1');
		}
	}
	if ($boardname =~ /P95_HP,HR,HQ/) {
		if (isDisplayPresent("AUO Model 21229 Serial Number 808797180")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog('detected backlight-fix issue', 'L1');
		}
	}




	# get the BIOS version
	# deactivated but could be useful if version changes in the future
	# $main::biosVersion = `dmidecode -s bios-version`;
	$main::biosVersion = '1.07.04NBC';
	$main::biosVersion =~ s/\s//g;
	if ($boardname =~ /NH5xAx/) {
		$origConfModules{corefix}{required} = 'yes';
		printLog('detected core-fix issue', 'L1');
	}

	# if Threeg Huawei ME936 device found
	$lsusb = `lsusb -d 12d1:15bb`;
	if ($lsusb =~ /ME936/) {
		$origConfModules{threegfix}{required} = 'yes';
		printLog('detected threeg-fix issue', 'L1');
	}

	# if Threeg Huawei ME906s device found
	$lsusb = `lsusb -d 12d1:15c1`;
	if ($lsusb =~ /huawei/i) {
		$origConfModules{threegfix2}{required} = 'yes';
		printLog('detected threeg-fix2 issue', 'L1');
	}

	if (($boardname =~ /X170SM/) ||
		($boardname =~ /X170KM-G/) ||
		($boardname =~ /PCx0Dx_GN20/) ||
		($boardname =~ /GMxZGxx/) ||
		($boardname =~ /GMxAGxx/) ||
		($boardname =~ /GMxTGxx/) ||
		($boardname =~ /GMxRGxx/)) {
		$origConfModules{tuxedokeyboardite}{required} = 'yes';
		printLog('detected tuxedo-keyboard-ite issue', 'L1');
	}

	# get vendor text from vendor ID:device ID
	my @tuxedonvmefixDevices = ('2646:2263');
	if ( findPciDevice($lspciOutput, @tuxedonvmefixDevices) ) {
		$origConfModules{tuxedonvmefix}{required} = 'yes';
		printLog('detected tuxedo-nvme-fix issue', 'L1');
	}

	my $fingerprintLsUsb = `lsusb`;
	my @fingerprintRegExp = (
		qr/147e:100[0123]/,
		qr/147e:20(15|16|20)/,
		qr/147e:300[01]/,
		qr/147e:500[23]/,
		qr/0483:201[56]/,
		qr/1c7a:0603/);
	foreach my $fpkey (map { $fingerprintLsUsb =~ $_ } @fingerprintRegExp) {
		$origConfModules{fingerprintreader}{required} = 'yes';
		printLog('detected fingerprint-reader issue', 'L1');
		last;
	}

	my @tuxedomicfix1Devices = (
	);
	if ( findPciDevice($lspciOutput, @tuxedomicfix1Devices) ) {
		$origConfModules{tuxedomicfix1}{required} = 'yes';
		printLog('detected tuxedo-micfix1 issue', 'L1');
	}

	if ($boardname =~ m/N350TW/) {
		$origConfModules{tuxedorestoreaudiofix}{required} = 'yes';
		printLog('detected tuxedo-restore-audio-fix issue', 'L1');
	}

	# get class codes from vendor ID
	my $nvidiaDevice = `lspci -nd 10de:`;
	if ($nvidiaDevice =~ /030[02]:/) {
		$origConfModules{nvidiadriver}{required} = 'yes';
		printLog('detected nvidia-driver issue', 'L1');
	}

	if ($boardname =~ m/NHxxRZQ/) {
		$origConfModules{r8168dkms}{required} = 'yes';
		printLog('detected r8168-dkms issue', 'L1');
	}
	if (isDisplayPresent("SDC Model 41001 Serial Number 0")) {
		$origConfModules{tuxedooledbrt}{required} = 'yes';
		printLog('detected tuxedo-oled-brt issue', 'L1');
	}
	if (isPackageInstalled('apport')) {
		# apportfix will always be installed as a workaround
		$origConfModules{apportfix}{required} = 'yes';
		printLog('detected apport-fix issue', 'L1');
	}
	if (($boardname =~ m/GMxNGxx/) ||
		($boardname =~ m/GMxZGxx/)) {
		if (isDisplayPresent("BOE Model 2423 Serial Number 0") ||
			isDisplayPresent("BOE Model 2420 Serial Number 0")) {
			$origConfModules{amdgpubacklightauxoff}{required} = 'yes';
			printLog('detected amdgpu-backlight-aux-off issue', 'L1');
		}
	}
	if (($boardname =~ m/PHxTxX1/) ||
		($boardname =~ m/PH4TQx1/) ||
		($boardname =~ m/PHxTQx1/)) {
		$origConfModules{i915enablepsrfix}{required} = 'yes';
		printLog('detected i915-enable-psr-fix issue', 'L1');
	}

	# kernel
	if (($completeDistVersion =~ /Ubuntu 20.04/) || ($completeDistVersion =~ /elementary OS 6.1/) || ($completeDistVersion =~ /KDE neon 20.04/) || ($completeDistVersion =~ /TUXEDO_OS Plasma 20.04/) || ($completeDistVersion =~ /TUXEDO OS 20.04/)) {
		if (($boardname =~ m/X170KM-G/) ||
			($boardname =~ m/PHxTxX1/) ||
			($boardname =~ m/PH4TQx1/) ||
			($boardname =~ m/PHxTQx1/)) {
			printLog('kernel linux-tuxedo-20.04-edge should be installed', 'L1');
			$origConfModules{kerneltuxedo2004edge}{required} = 'yes';
		} elsif (($boardname =~ m/GMxZGxx/) ||
				($boardname =~ m/NL5xNU/)) {
			printLog('kernel linux-tuxedo-20.04-next should be installed', 'L1');
			$origConfModules{kerneltuxedo2004next}{required} = 'yes';
		} else {
			printLog('kernel linux-tuxedo-20.04 will be default', 'L1');
			$origConfModules{kerneltuxedo2004}{required} = 'yes';
		}
	} elsif (($completeDistVersion =~ /Ubuntu 22.04/) || ($completeDistVersion =~ /TUXEDO OS 22.04/)) {
		printLog('kernel linux-tuxedo-22.04 will be default', 'L1');
		$origConfModules{kerneltuxedo2204}{required} = 'yes';
	}

	if ($boardname =~ m/X170KM-G/) {
		$origConfModules{thunderboltbootdelayfix}{required} = 'yes';
		printLog('detected thunderbolt-boot-delay-fix issue', 'L1');
	}

	if ((($boardname =~ m/NV4XMB,ME,MZ/) ||
		($boardname =~ m/PHxTQx1/) ||
		($boardname =~ m/PH4TQx1/)) && (-d '/etc/lightdm/')) {
		$origConfModules{lightdmlogindcheckgraphicalfix}{required} = 'yes';
		printLog('detected lightdm-logind-check-graphical-fix issue', 'L1');
	}

	if ($boardname =~ m/GMxTGxx/) {
		$origConfModules{nvidiabacklightcontrolfix}{required} = 'yes';
		printLog('detected nvidia-backlight-control-fix issue', 'L1');
	}

	if (($boardname =~ m/NV4XMB,ME,MZ/) ||
		($boardname =~ m/PHxTQx1/)) {
		$origConfModules{earlyloadbacklightcontrolfix}{required} = 'yes';
		printLog('detected early-load-backlight-control-fix issue', 'L1');
	}

	my @r8125Devices = ('10ec:8125');
	if ( findPciDevice($lspciOutput, @r8125Devices) ) {
		$origConfModules{r8125dkms}{required} = 'yes';
		printLog('detected r8125dkms issue', 'L1');
	}

	# if cardreader Realtek RTS522A found
	my @cardreaderDevices = (qr/10ec:522a/); 
	if ( findPciDevice($lspciOutput, @cardreaderDevices) ) {
		$origConfModules{cardreaderfix}{required} = 'yes';
		printLog('detected cardreader-fix issue', 'L1');
	}

	if ($boardname =~ m/PF5LUXG/)	{
		$origConfModules{samsungnvmefix}{required} = 'yes';
		printLog('detected samsung-nvme-fix issue', 'L1');
	}
}



###############################################################################
# returns true if the PCI device or subdevice was found
# parameter is an array of PCI devices (RegExp are allowed)
#
sub findPciDevice {
	my ($lspciList, @pciDevices) = @_;
	my $pciDevice;
	foreach $pciDevice (@pciDevices) {
		if ($lspciList =~ /$pciDevice/) {
			return (1);
		}
	}
	return (0);
}


###############################################################################
###############################################################################
###############################################################################
# each configure one module from %confModules
# they set 'installed' status and $postConfModule trigger
#
# for keyboard not present on boot
#
sub i8042fix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("i8042.nopnp");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}



###############################################################################
# for touchpad problems
#
sub i8042noauxfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("i8042.noaux");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}




###############################################################################
# deletes iommu=soft from grub
# was before for not being able to boot if system is on battery and used to set
# iommu=soft on grub
# affects BA15
# - PF5PU1G
#
sub nobootonbattery() {
	my $module = shift;
	my $action = shift;
	my $retval = -1;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		if (isTextInFile('/etc/default/grub', 'iommu=soft')) {
			$retval = replaceTextInFile('/etc/default/grub', 'iommu=soft', '');
		}
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		if (isTextInFile('/etc/default/grub', 'iommu=soft')) {
			$retval = replaceTextInFile('/etc/default/grub', 'iommu=soft', '');
		}
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}


###############################################################################
# Fix for some AMD devices where the xhci_hcd driver causes a jump out of
# suspend immediately on entering suspend
# - POLARIS1501A1650TI
# - POLARIS1501A2060
# - POLARIS1701A1650TI
# - POLARIS1701A2060
# - PULSE1401
# - PULSE1501
# - AURA1501/NL5xRU
# - EDUBOOK1502
#
sub amdxhcihcdusbquirksuspendfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("xhci_hcd.quirks=1073741824");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}


###############################################################################
# Enables activation of discrete NVIDIA graphics on devices with built-in AMD
# graphics. Also enables switching between the two with prime-select
# affects:
# - POLARIS1701A1650TI
# - POLARIS1701A2060
# - POLARIS1501A1650TI
# - POLARIS1501A2060
#
sub amdgpuwithnvidiafix() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $filename = '/usr/share/X11/xorg.conf.d/00-tuxedo-nvidia-amdgpu-fix.conf';
	my $niceTime = getBackupFileTime();
	my $fileText = "# added by tuxedo-tomte ".$niceTime."\n".
		"Section \"OutputClass\"\n".
		"\tIdentifier \"nvidia\"\n".
    	"\tMatchDriver \"nvidia-drm\"\n".
    	"\tDriver \"nvidia\"\n".
    	"\tOption \"AllowEmptyInitialConfiguration\"\n".
    	"\tModulePath \"/usr/lib/x86_64-linux-gnu/nvidia/xorg\"\n".
    	"\tOption \"PrimaryGPU\" \"Yes\"\n".
		"EndSection\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = createFile($filename, $fileText, 1);
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$origConfModules{$module}{installed} = "yes";
		$origConfModules{$module}{upgraded} = "yes";
		addToConfiguredModules($module, "success");
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			printLog("removing $module", 'TL0');
			unlink glob ("/usr/share/X11/xorg.conf.d/00-tuxedo-nvidia-amdgpu-fix.conf_*");
			if (backupFile($filename)) {
				unlink($filename);
			} else {
				printLog('can\'t remove fix, it seems to be gone already', 'TL1');
			}
			$origConfModules{$module}{installed} = 'no';
			$origConfModules{$module}{upgraded} = 'yes';
			addToConfiguredModules($module, 'removed');
		}
	}
}


###############################################################################
# TUXEDO Control Center application
#
sub tuxedocontrolcenter() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages, it is done by the package manager");
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# Keyboard & keyboard backlight driver for TUXEDO notebooks
#
sub tuxedokeyboard() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}





###############################################################################
# Fix for TUXEDO Notebooks, fixes no keyboard present after suspend on
# - XC1711
# - XUX711
# - NH5xAx
# - AURA1501/NL5xRU
# - PB50_70DFx,DDx
# - N150CU
# - N141CU
# - XC15 
# - IBS15v6
# - EDUBOOK1502
#
sub nokeyboardaftersuspendfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("i8042.reset", "i8042.nomux", "i8042.nopnp", "i8042.noloop");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}


###############################################################################
# Fixes backlight issue with AUO Model 12701 and 21229 displays on
# - DX1708
# - P95_HP
# - P95_HR
# - P95_HP,HR,HQ
#
sub backlightfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("i915.enable_dpcd_backlight=1");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;	
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}




###############################################################################
# Adds the TUXEDO repos to the system
#
sub tuxedorepos() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $retval2;
	my $exitStatus;
	my $output;

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = createRepos(\%tuxedo_repos);
		if ($retval > 0) {
			$retval2 = addRepoKey();
		}
		if (($retval == 0) && ($retval2 == 0)) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			if ($retval == 1) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifications on repos', 'L1');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# repo updates have to be immediate for possible later package
				# installation
				if (!$FAI) {
					checkNetwork(10,10);
					unlockPackageManagement('pkcon refresh');
					$output = `pkcon refresh`;
					lockPackageManagement();
					$exitStatus = $?/256;
					if ($exitStatus != 0) {
						printLog('failed: update packages', 'L0');
						printLog("returned error code: $exitStatus", 'L0');
						if ($exitStatus == 7) {
							printLog('possible network problems', 'L0');
						}
						addToConfiguredModules($module, "failed");
					} else {
						printLog("success: update packages", 'L1');
						addToConfiguredModules($module, "success");
					}
				}
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("uprading $origConfModules{$module}{name}", 'L1');
		backupFile('/etc/apt/sources.list');
		$retval = createRepos(\%tuxedo_repos);
		if ($retval > 0) {
			$retval2 = addRepoKey();
		}
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			if ($retval == 1) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifications on repos', 'L1');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# update of repos has to be immediate for possible later package
				# installation
				checkNetwork(10,10);
				unlockPackageManagement('pkcon refresh');
				$output = `pkcon refresh`;
				lockPackageManagement();
				$exitStatus = $?/256;
				if ($exitStatus != 0) {
					printLog('failed: update packages', 'L0');
					printLog("returned error code: $exitStatus", 'L0');
					if ($exitStatus == 7) {
						printLog('possible network problems', 'L0');
					}
					addToConfiguredModules($module, "failed");
				} else {
					printLog('success: update packages', 'L1');
					addToConfiguredModules($module, "success");
				}
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("This is a prerequisite, removal is not possible for this module", 'TL0');
	}
}


###############################################################################
# Adds the TUXEDO mirrors to the system
#
sub tuxedomirrors() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $retval2;
	my $retval3;
	my $exitStatus;
	my $output;

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = createRepos(\%tuxedo_mirrors);
		$retval3 = cleanSourcesList();
		if ($retval > 0) {
			$retval2 = addRepoKey();
		}
		if (($retval == 0) && ($retval2 == 0)) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			if (($retval == 1) && ($retval3 == 0)) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifications on mirrors', 'L1');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# update of repos has to be immediate for possible later package
				# installation
				if (!$FAI) {
					checkNetwork(10,10);
					unlockPackageManagement('pkcon refresh');
					$output = `pkcon refresh`;
					lockPackageManagement();
					$exitStatus = $?/256;
					if ($exitStatus != 0) {
						printLog('failed: update packages', 'L1');
						printLog("returned error code: $exitStatus", 'L1');
						if ($exitStatus == 7) {
							printLog('possible network problems', 'L1');
						}
						addToConfiguredModules($module, "failed");
					} else {
						printLog("success: update packages", 'L1');
						addToConfiguredModules($module, "success");
					}
				}
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("uprading $origConfModules{$module}{name}", 'L1');
		backupFile('/etc/apt/sources.list');
		$retval = createRepos(\%tuxedo_mirrors);
		if ($retval > 0) {
			$retval2 = addRepoKey();
		}
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			if ($retval == 1) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifications on mirrors', 'L1');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# update of repos has to be immediate for possible later package
				# installation
				checkNetwork(10,10);
				unlockPackageManagement('pkcon refresh');
				$output = `pkcon refresh`;
				lockPackageManagement();
				$exitStatus = $?/256;
				if ($exitStatus != 0) {
					printLog('failed: update packages', 'L0');
					printLog("returned error code: $exitStatus", 'L0');
					if ($exitStatus == 7) {
						printLog('possible network problems', 'L0');
					}
					addToConfiguredModules($module, "failed");
				} else {
					printLog('success: update packages', 'L1');
					addToConfiguredModules($module, "success");
				}
			}
		}
	}
	if ($action eq 'remove') {
		printLog("This removed the module from the list only, manual intervention is necessary to remove the respective repositories", 'TL0');
		addToConfiguredModules($module, "removed");
		$origConfModules{$module}{installed} = "no";
		$origConfModules{$module}{upgraded} = "yes";
		$origConfModules{$module}{required} = "no";
	}
}


###############################################################################
# Adds the core-fix for certain BIOS versions on certain mainboards
#
sub corefix() {
	my $module = shift;
	my $action = shift;
	if ($main::biosVersion eq "") {
		printLog("BIOS version empty", 'L1');
		$origConfModules{$module}{installed} = "failed";
		addToConfiguredModules($module, "failed");
		return(0);
	}
	my $amlHookScript = 'tuxedo-corefix-clevo-nh5xax';
	my $amlHookScriptOrig = $shareDir.$amlHookScript;
	my $amlHookDirDest = '/etc/initramfs-tools/hooks/';
	my $amlHookScriptDest = $amlHookDirDest.$amlHookScript;
	my %amlFile = (
		'1.07.04NBC' => 'nh5xax-1.aml',
	);
	my $amlFileOrig = $shareDir.$amlFile{$main::biosVersion};
	my $amlFileDirDest = '/lib/firmware/tuxedo-corefix-clevo-nh5xax/';
	$amlFile{$main::biosVersion} =~ s/-\d*//;
	my $amlFileDest = $amlFileDirDest.$amlFile{$main::biosVersion};

	if ($action eq 'install') {
		if (($argValue{command} eq 'configure') || ($argValue{command} eq 'reconfigure')) {
			messageLongInstall();
			printLog("applying $origConfModules{$module}{name}", 'L1');
			mkdir($amlFileDirDest, 0644) unless(-d $amlFileDirDest);
			copy($amlFileOrig, $amlFileDest);
			mkdir($amlHookDirDest, 0644) unless(-d $amlHookDirDest);
			copy($amlHookScriptOrig, $amlHookScriptDest);
			chmod 0700, $amlHookScriptDest;

			if ((-e $amlFileDest) and (-e $amlHookScriptDest)) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$postConfProgram{updateInitramfs}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
		}
	}
	if ($action eq 'upgrade') {
		# not implemented yet
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# Fixes problem with Elantech touchpad
# affects InfinityBook 14 v2
# - X35R
#
sub elantechtouchpadfix() {
my $module = shift;
my $action = shift;
my @kernelParameters = ("psmouse.elantech_smbus=0");
my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
        if ($retval < 0) {
            $origConfModules{$module}{installed} = "failed";
            addToConfiguredModules($module, "failed");
        } else {
            $origConfModules{$module}{installed} = "yes";
            $origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
            	addToConfiguredModules($module, "success");
            	$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
        }
    }
    if ($action eq 'upgrade') {
        printLog("upgrading $origConfModules{$module}{name}", 'L1');
        $retval = insertGrub($module, \@kernelParameters);
        if ($retval < 0) {
            $origConfModules{$module}{installed} = "failed";
            addToConfiguredModules($module, "failed");
        } else {
            $origConfModules{$module}{installed} = "yes";
            $origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
            	addToConfiguredModules($module, "success");
            	$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
        }
    }
    if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
    }
}



###############################################################################
# Creates a configuration to use Huawei-ME936
# - if USB device 12d1:15bb detected
#
sub threegfix() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $retval2;
	my $filename1 = '/etc/modprobe.d/huawei-me936.conf';
	my $filename2 = '/lib/udev/rules.d/77-mm-huawei-configuration.rules';
	my $niceTime = getBackupFileTime();
	my $fileText1 = "# added by tuxedo-tomte ".$niceTime."\n".
		"options usbserial vendor=0x12d1 product=0x15bb\n";
	my $fileText2 = "# added by tuxedo-tomte ".$niceTime."\n".
		"ACTION==\"add|change\", SUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\", ATTR{idVendor}==\"12d1\", ATTR{idProduct}==\"15bb\", ATTR{bNumConfigurations}==\"3\", ATTR{bConfigurationValue}!=\"3\" ATTR{bConfigurationValue}=\"3\"\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval1 = createFile($filename1, $fileText1, 1);
		$retval2 = createFile($filename2, $fileText2, 1);
		if ($retval1 == 0 || $retval2 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval1 = createFile($filename1, $fileText1, 1);
		$retval2 = createFile($filename2, $fileText2, 1);
		if ($retval1 == 0 || $retval2 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# Creates a configuration to use Huawei-ME906s
# - if USB device 12d1:15c1 detected
# !!!! not tested, could not work at all but should not have any negative
# effects
#
sub threegfix2() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $retval2;
	my $filename1 = '/etc/modprobe.d/huawei-me906s.conf';
	my $filename2 = '/lib/udev/rules.d/77-mm-huawei-configuration.rules';
	my $niceTime = getBackupFileTime();
	my $fileText1 = "# added by tuxedo-tomte ".$niceTime."\n".
		"options usbserial vendor=0x12d1 product=0x15c1\n";
	my $fileText2 = "# added by tuxedo-tomte ".$niceTime."\n".
		"ACTION==\"add|change\", SUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\", ATTR{idVendor}==\"12d1\", ATTR{idProduct}==\"15c1\", ATTR{bNumConfigurations}==\"3\", ATTR{bConfigurationValue}!=\"2\", ATTR{bConfigurationValue}=\"2\"";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval1 = createFile($filename1, $fileText1, 1);
		$retval2 = createFile($filename2, $fileText2, 1);
		if ($retval1 == 0 || $retval2 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval1 = createFile($filename1, $fileText1, 1);
		$retval2 = createFile($filename2, $fileText2, 1);
		if ($retval1 == 0 || $retval2 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}




###############################################################################
# Uniwill touchpad LED fix
#
sub tuxedotouchpadswitch() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages", 'L1');
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# Kingston A2000 NVME drives freezing after deep APST sleep fix
#
sub tuxedonvmefix() {
	my $module = shift;
	my $action = shift;
	my %nvmeDevice;
	my $nvmeDir;
	my $output;
	my $fwVersion = 'S5Z42109';
	my $nvmeUpdateSuccess = 0;
	my $nvmeFWPackageWasInstalled = 0;
	if (isPackageInstalled('tuxedo-nvme-fix')) {
		if (! deinstallPackage('tuxedo-nvme-fix')) {
			printLog('obsolete package tuxedo-nvme-fix was successfully removed', 'L0');
		} else {
			printLog('could not remove obsolete package tuxedo-nvme-fix, will try again next time', 'L0');
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
			return (0);
		}
	}
	if (($action eq 'install') || ($action eq 'upgrade')) {
		while ( defined ($nvmeDir = glob '/sys/class/nvme/*' )) {
			$nvmeDevice{$nvmeDir}{'device'} = $nvmeDir;
			$nvmeDevice{$nvmeDir}{'device'} =~ /.*(nvme.*)/;
			$nvmeDevice{$nvmeDir}{'device'} = '/dev/'.$1;
			$nvmeDevice{$nvmeDir}{'model'} = readFileReturnLine("$nvmeDir/model");
			$nvmeDevice{$nvmeDir}{'subdevice'} = readFileReturnLine("$nvmeDir/device/subsystem_device");
			$nvmeDevice{$nvmeDir}{'subvendor'} = readFileReturnLine("$nvmeDir/device/subsystem_vendor");
			$nvmeDevice{$nvmeDir}{'firmware'} = readFileReturnLine("$nvmeDir/firmware_rev");
		}
		foreach $nvmeDir ( keys %nvmeDevice ) {
			if (($nvmeDevice{$nvmeDir}{model} =~ /SA2000M8(?:25|50|100)0G/) &&
				($nvmeDevice{$nvmeDir}{subdevice} =~ /0x2263/) &&
				($nvmeDevice{$nvmeDir}{subvendor} =~ /0x2646/)) {
				printLog("nvme device on $nvmeDevice{$nvmeDir}{'device'}", 'L1');
				if ($nvmeDevice{$nvmeDir}{firmware} lt $fwVersion) {
					printLog("firmware upgrade required", 'L0');
					# firmware upgrade is required
					if (! isPackageInstalled('nvme-cli')) {
						if (! installPackage('nvme-cli')) {
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
					}
					if (isPackageInstalled('a2000-s5z42109')) {
						$nvmeFWPackageWasInstalled = 1;
					}
					if (installPackage('a2000-s5z42109')) {
						printLog("upload firmware on $nvmeDevice{$nvmeDir}{'device'}", 'L1');
						$output = `nvme fw-download $nvmeDevice{$nvmeDir}{'device'} -f /lib/firmware/a2000/$fwVersion.bin`;
						if ($? != 0) {
							printLog('firmware could not be uploaded!', 'L0');
							printLog($output);
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
						printLog("activate firmware on $nvmeDevice{$nvmeDir}{'device'}");
						$output = `nvme fw-activate $nvmeDevice{$nvmeDir}{'device'} --slot=1 --action=1`;
						if ($? != 0) {
							printLog('firmware could not be activated');
							printLog($output);
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
						$restartSystem = 1;
						$origConfModules{$module}{installed} = "yes";
						$origConfModules{$module}{upgraded} = "yes";
						printLog('nvme firmware was successfully updated', 'L0');
						$nvmeUpdateSuccess = 1;
					} else {
						$origConfModules{$module}{installed} = "failed";
						addToConfiguredModules($module, "failed");
						return (0);
					}
				} else {
					printLog("firmware already installed on $nvmeDevice{$nvmeDir}{'device'}", 'L1');
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
				}
			}
		}
		if ($nvmeUpdateSuccess) {
			addToConfiguredModules($module, "success");
		} else {
			addToConfiguredModules($module, "nothingToDo");
		}
		if (! $nvmeFWPackageWasInstalled) {
			deinstallPackage('a2000-s5z42109');
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}




###############################################################################
# tuxedo-keyboard-ite
#
sub tuxedokeyboardite() {
	my $module = shift;
	my $action = shift;
	if (($action eq 'install') && (!$FAI)) {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	} else {
		$origConfModules{$module}{installed} = 'failed';
		addToConfiguredModules($module, 'failed');
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages", 'L1');
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# fingerprint-reader
#
sub fingerprintreader() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packagefprintd;
	my $packagelibpam;
	if ($action eq 'install') {
		# check if the package is already installed
		if( ! isPackageInstalled('fprintd') ) {
			$wasInstalled = 0;
			messageLongInstall();
			$packagefprintd = installPackage('fprintd');
		} else {
			$packagefprintd = 1;
		}
		if( ! isPackageInstalled('libpam-fprintd') ) {
			$wasInstalled = 0;
			messageLongInstall();
			$packagelibpam = installPackage('libpam-fprintd');
		} else {
			$packagelibpam = 1;
		}

		if( $packagefprintd && $packagelibpam ) {
			if ($wasInstalled) {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			} else {
				addToConfiguredModules($module, 'success');
			}
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
		} else {
			$origConfModules{$module}{installed} = 'failed';
			addToConfiguredModules($module, 'failed');
		}
	}
	if ($action eq 'upgrade') {
		printLog('upgrade not necessary for packages', 'L1');
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# tuxedo-micfix1
#
sub tuxedomicfix1() {
	my $module = shift;
	my $action = shift;
	if (($action eq 'install') && (!$FAI)) {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = 'yes';
				$origConfModules{$module}{upgraded} = 'yes';
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = 'failed';
				addToConfiguredModules($module, 'failed');
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
		}
	} else {
		$origConfModules{$module}{installed} = 'failed';
		addToConfiguredModules($module, 'failed');
	}
	if ($action eq 'upgrade') {
		printLog('upgrade not necessary for packages', 'L1');
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}




###############################################################################
# Mesa-utils
#
sub mesautils() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages", 'L1');
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# Rescans the pci bus to reactivate missing audio device
# - N350TW
#
sub tuxedorestoreaudiofix() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $retval2;
	my $filename = '/lib/systemd/system/restore-audiocards.service';
	my $fileText = "# added by tuxedo-tomte \n".
		"[Unit]\n".
		"Description=Rescan the PCI-Bus for missed audio cards\n".
		"After=alsa-restore.service\n".
		"\n".
		"[Service]\n".
		"Type=oneshot\n".
		"RemainAfterExit=false\n".
		"ExecStart=/usr/bin/bash -c 'echo auto >> /sys/devices/pci0000:00/0000:00:1f.3/power/control'\n".
		"ExecStart=/usr/bin/sleep 1\n".
		"ExecStart=/usr/bin/bash -c 'echo 1 >> /sys/devices/pci0000:00/0000:00:1f.3/remove'\n".
		"ExecStart=/usr/bin/sleep 1\n".
		"ExecStart=/usr/bin/bash -c 'echo 1 >> /sys/bus/pci/rescan'\n".
		"\n".
		"[Install]\n".
		"WantedBy=multi-user.target\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval1 = createFile($filename, $fileText, 1);
		$retval2 = system('systemctl --now enable restore-audiocards.service');
		if ($retval1 == 0 || $retval2 != 0) {
			if ($retval2 != 0) {
				printLog('systemd could not initialize restore-audiocards.service', 'L0');
			}
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'upgrade') {
		printLog("no upgrade available yet for tuxedo-restore-audio-fix", 'L1');
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}




###############################################################################
# kernel HWE 18.04 and 20.04
#
sub kernelhwe2004() {
	my $module = shift;
	my $action = shift;
	my $instFailed = 0;
	my $instDone = 0;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		if (($completeDistVersion =~ /Ubuntu 20.04/) || ($completeDistVersion =~ /elementary OS 6.1/) || ($completeDistVersion =~ /KDE neon 20.04/) || ($completeDistVersion =~ /TUXEDO_OS Plasma 20.04/) || ($completeDistVersion =~ /TUXEDO OS 20.04/)) {
			installKernelFlavour('linux-generic-hwe-20.04', $instFailed, $instDone);
			if ($instFailed == 0) {
				uninstallAllOtherKernelFlavours('linux-generic-hwe-20.04', \$instFailed, \$instDone);
			}
			if ($instFailed > 0) {
				startTomteDelayed();
				addToConfiguredModules($module, "failed");
				$origConfModules{$module}{installed} = "failed";
			} elsif ($instDone > 0) {
				addToConfiguredModules($module, "success");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$restartSystem = 1;
			} else {
				addToConfiguredModules($module, "nothingToDo");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}





###############################################################################
# kernel-tuxedo-20.04-edge
#
sub kerneltuxedo2004edge() {
	my $module = shift;
	my $action = shift;
	my $instFailed = 0;
	my $instDone = 0;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		if (($completeDistVersion =~ /Ubuntu 20.04/) || ($completeDistVersion =~ /elementary OS 6.1/) || ($completeDistVersion =~ /KDE neon 20.04/) || ($completeDistVersion =~ /TUXEDO_OS Plasma 20.04/) || ($completeDistVersion =~ /TUXEDO OS 20.04/)) {
			installKernelFlavour('linux-tuxedo-20.04-edge', $instFailed, $instDone);
			if ($instFailed == 0) {
				uninstallAllOtherKernelFlavours('linux-tuxedo-20.04-edge', \$instFailed, \$instDone);
			}
			if ($instFailed > 0) {
				startTomteDelayed();
				addToConfiguredModules($module, "failed");
				$origConfModules{$module}{installed} = "failed";
			} elsif ($instDone > 0) {
				addToConfiguredModules($module, "success");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$restartSystem = 1;
			} else {
				addToConfiguredModules($module, "nothingToDo");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# kernel-tuxedo-20.04-next
#
sub kerneltuxedo2004next() {
	my $module = shift;
	my $action = shift;
	my $instFailed = 0;
	my $instDone = 0;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		if (($completeDistVersion =~ /Ubuntu 20.04/) || ($completeDistVersion =~ /elementary OS 6.1/) || ($completeDistVersion =~ /KDE neon 20.04/) || ($completeDistVersion =~ /TUXEDO_OS Plasma 20.04/) || ($completeDistVersion =~ /TUXEDO OS 20.04/)) {
			installKernelFlavour('linux-tuxedo-20.04-next', $instFailed, $instDone);
			if ($instFailed == 0) {
				uninstallAllOtherKernelFlavours('linux-tuxedo-20.04-next', \$instFailed, \$instDone);
			}
			if ($instFailed > 0) {
				startTomteDelayed();
				addToConfiguredModules($module, "failed");
				$origConfModules{$module}{installed} = "failed";
			} elsif ($instDone > 0) {
				addToConfiguredModules($module, "success");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$restartSystem = 1;
			} else {
				addToConfiguredModules($module, "nothingToDo");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}




###############################################################################
# kernel-tuxedo-20.04
#
sub kerneltuxedo2004() {
	my $module = shift;
	my $action = shift;
	my $instFailed = 0;
	my $instDone = 0;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		if (($completeDistVersion =~ /Ubuntu 20.04/) || ($completeDistVersion =~ /elementary OS 6.1/) || ($completeDistVersion =~ /KDE neon 20.04/) || ($completeDistVersion =~ /TUXEDO_OS Plasma 20.04/) || ($completeDistVersion =~ /TUXEDO OS 20.04/)) {
			installKernelFlavour('linux-tuxedo-20.04', $instFailed, $instDone);
			if ($instFailed == 0) {
				uninstallAllOtherKernelFlavours('linux-tuxedo-20.04', \$instFailed, \$instDone);
			}
			if ($instFailed > 0) {
				startTomteDelayed();
				addToConfiguredModules($module, "failed");
				$origConfModules{$module}{installed} = "failed";
			} elsif ($instDone > 0) {
				addToConfiguredModules($module, "success");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$restartSystem = 1;
			} else {
				addToConfiguredModules($module, "nothingToDo");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# kernel-tuxedo-22.04
#
sub kerneltuxedo2204() {
	my $module = shift;
	my $action = shift;
	my $instFailed = 0;
	my $instDone = 0;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		if (($completeDistVersion =~ /Ubuntu 22.04/) || ($completeDistVersion =~ /TUXEDO OS 22.04/)) {
			installKernelFlavour('linux-tuxedo-22.04', $instFailed, $instDone);
			if ($instFailed == 0) {
				uninstallAllOtherKernelFlavours('linux-tuxedo-22.04', \$instFailed, \$instDone);
			}
			if ($instFailed > 0) {
				startTomteDelayed();
				addToConfiguredModules($module, "failed");
				$origConfModules{$module}{installed} = "failed";
			} elsif ($instDone > 0) {
				addToConfiguredModules($module, "success");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$restartSystem = 1;
			} else {
				addToConfiguredModules($module, "nothingToDo");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}




###############################################################################
# nvidiadriver
# installs TUXEDO approved nvidia drivers and removes all the other ones
#
sub nvidiadriver() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packageNvidiaDriver;
	my $packageMesaUtils;
	my $packageNvidiaPrime;
	my $packagePythonAppindicator;
	my $packagePythonCairo;
	my $packagePythonGtk2;
	my $oldDriversRemoved;
	my $output;
	my $nvidiaDriver = 'nvidia-driver-510';
	if (($action eq 'install') || ($action eq 'upgrade')) {
		if ($completeDistVersion =~ /Ubuntu 18.04/) {
			# deinstall other nvidia drivers
			$oldDriversRemoved = deinstExcept('nvidia-driver-', $nvidiaDriver);

			# check if the package is already installed
			if( ! isPackageInstalled($nvidiaDriver) ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageNvidiaDriver = installPackage($nvidiaDriver);
			} else {
				setAptMark($nvidiaDriver,'manual');
				$packageNvidiaDriver = 1;
			}
			if( ! isPackageInstalled('mesa-utils') ) {
				$wasInstalled = 0;
				$packageMesaUtils = installPackage('mesa-utils');
			} else {
				$packageMesaUtils = 1;
			}
			if( ! isPackageInstalled('nvidia-prime') ) {
				$wasInstalled = 0;
				$packageNvidiaPrime = installPackage('nvidia-prime');
			} else {
				$packageNvidiaPrime = 1;
			}
			if( ! isPackageInstalled('python-appindicator') ) {
				$wasInstalled = 0;
				$packagePythonAppindicator = installPackage('python-appindicator');
			} else {
				$packagePythonAppindicator = 1;
			}
			if( ! isPackageInstalled('python-cairo') ) {
				$wasInstalled = 0;
				$packagePythonCairo = installPackage('python-cairo');
			} else {
				$packagePythonCairo = 1;
			}
			if( ! isPackageInstalled('python-gtk2') ) {
				$wasInstalled = 0;
				$packagePythonGtk2 = installPackage('python-gtk2');
			} else {
				$packagePythonGtk2 = 1;
			}
	
			if( $oldDriversRemoved && $packageNvidiaDriver && $packageMesaUtils && $packageNvidiaPrime && $packagePythonAppindicator && $packagePythonCairo && $packagePythonGtk2 ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed", 'L1');
					addToConfiguredModules($module, "nothingToDo");
				} else {
					addToConfiguredModules($module, "success");
					$restartSystem = 1;
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		
		} elsif (($completeDistVersion =~ /Ubuntu 20.04/) || ($completeDistVersion =~ /elementary OS 6.1/) || ($completeDistVersion =~ /KDE neon 20.04/) || ($completeDistVersion =~ /TUXEDO_OS Plasma 20.04/) || ($completeDistVersion =~ /TUXEDO OS 20.04/)) {
			# deinstall other nvidia drivers
			$oldDriversRemoved = deinstExcept('nvidia-driver-', $nvidiaDriver);

			# check if the package is already installed
			if( ! isPackageInstalled($nvidiaDriver) ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageNvidiaDriver = installPackage($nvidiaDriver);
			} else {
				setAptMark($nvidiaDriver,'manual');
				$packageNvidiaDriver = 1;
			}
			if( ! isPackageInstalled('mesa-utils') ) {
				$wasInstalled = 0;
				$packageMesaUtils = installPackage('mesa-utils');
			} else {
				$packageMesaUtils = 1;
			}
			if( ! isPackageInstalled('nvidia-prime') ) {
				$wasInstalled = 0;
				$packageNvidiaPrime = installPackage('nvidia-prime');
			} else {
				$packageNvidiaPrime = 1;
			}

			if( $packageNvidiaDriver && $packageNvidiaPrime ) {
				# temporarily activated fix
				if ($FAI || ($origConfModules{$module}{installed} eq 'no')) {
					$output = `gpu-manager && prime-select nvidia`;
					printLog('selecting NVIDIA GPU: on', 'TL0');
					printLog("$output", 'L2');
				}
			}

			if( $oldDriversRemoved && $packageNvidiaDriver && $packageMesaUtils && $packageNvidiaPrime ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed", 'L1');
					addToConfiguredModules($module, "nothingToDo");
				} else {
					printLog("installed $origConfModules{$module}{name}", 'L1');
					addToConfiguredModules($module, "success");
					$restartSystem = 1;
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				printLog("$origConfModules{$module}{name} installation failed", 'L1');
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} elsif (($completeDistVersion =~ /Ubuntu 22.04/) || ($completeDistVersion =~ /TUXEDO_OS Plasma 22.04/) || ($completeDistVersion =~ /TUXEDO OS 22.04/)) {
			# deinstall other nvidia drivers
			$oldDriversRemoved = deinstExcept('nvidia-driver-', $nvidiaDriver);

			# check if the package is already installed
			if( ! isPackageInstalled($nvidiaDriver) ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageNvidiaDriver = installPackage($nvidiaDriver);
			} else {
				setAptMark($nvidiaDriver,'manual');
				$packageNvidiaDriver = 1;
			}
			if( ! isPackageInstalled('mesa-utils') ) {
				$wasInstalled = 0;
				$packageMesaUtils = installPackage('mesa-utils');
			} else {
				$packageMesaUtils = 1;
			}
			if( ! isPackageInstalled('nvidia-prime') ) {
				$wasInstalled = 0;
				$packageNvidiaPrime = installPackage('nvidia-prime');
			} else {
				$packageNvidiaPrime = 1;
			}

			if( $packageNvidiaDriver && $packageNvidiaPrime ) {
				# temporarily activated fix
				if ($FAI || ($origConfModules{$module}{installed} eq 'no')) {
					$output = `gpu-manager && prime-select nvidia`;
					printLog('selecting NVIDIA GPU: on', 'TL0');
					printLog("$output", 'L2');
				}
			}

			if( $oldDriversRemoved && $packageNvidiaDriver && $packageMesaUtils && $packageNvidiaPrime ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed", 'L1');
					addToConfiguredModules($module, "nothingToDo");
				} else {
					printLog("installed $origConfModules{$module}{name}", 'L1');
					addToConfiguredModules($module, "success");
					$restartSystem = 1;
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				printLog("$origConfModules{$module}{name} installation failed", 'L1');
				printLog("old drivers removed: $oldDriversRemoved", 'L1');
				printLog("package nvidia-driver: $packageNvidiaDriver", 'L1');
				printLog("package mesa-utils: $packageMesaUtils", 'L1');
				printLog("package nvidia-prime: $packageNvidiaPrime", 'L1');
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("unknown distribution/flavour, can't install nvidia drivers", 'TL0');
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# cracklib-runtime
#
sub cracklibruntime() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages", 'L1');
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# Fixes AMD GPU frequency communication with display
# !! deprecated since 20220216
#
sub amdgpudkms() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packageamdgpu_dkms_firmware;
	my $packageamdgpu_dkms;
	if ($action eq 'install') {
		# check if the package is already installed
		if( ! isPackageInstalled('amdgpu-dkms-firmware') ) {
			messageLongInstall();
			$wasInstalled = 0;
			$packageamdgpu_dkms_firmware = installPackage('amdgpu-dkms-firmware');
		} else {
			$packageamdgpu_dkms_firmware = 1;
		}
		if( ! isPackageInstalled('amdgpu-dkms') ) {
			messageLongInstall();
			$wasInstalled = 0;
			$packageamdgpu_dkms = installPackage('amdgpu-dkms');
		} else {
			$packageamdgpu_dkms = 1;
		}

		if( $packageamdgpu_dkms_firmware && $packageamdgpu_dkms ) {
			if ($wasInstalled) {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			} else {
				addToConfiguredModules($module, 'success');
			}
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
		} else {
			$origConfModules{$module}{installed} = 'failed';
			addToConfiguredModules($module, 'failed');
		}
	}
	if ($action eq 'upgrade') {
		printLog('upgrade not necessary for packages', 'L1');
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			my $counter = 0;
			if( isPackageInstalled('amdgpu-dkms') ) {
				if (!deinstallPackage('amdgpu-dkms')) {
					$counter = $counter+1;
				}
			} else {
				$counter = $counter+1;
			}
			if( isPackageInstalled('amdgpu-dkms-firmware') ) {
				if (!deinstallPackage('amdgpu-dkms-firmware')) {
					$counter = $counter+1;
				}
			} else {
				$counter = $counter+1;
			}
			if ($counter == 2) {
				$origConfModules{$module}{installed} = 'no';
				$origConfModules{$module}{upgraded} = 'yes';
				addToConfiguredModules($module, 'removed');
			} else {
				$origConfModules{$module}{installed} = 'yes';
				$origConfModules{$module}{upgraded} = 'no';
				addToConfiguredModules($module, 'remove failed');
			}
		}
	}
}



###############################################################################
# Installs Linux device driver for several Realtek Ethernet controllers
#
sub r8168dkms() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages", 'L1');
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# Installs package tuxedo-oled-brt to control the brightness of OLED displays
# using xrandr and dbus
# The original program is from System76 https://github.com/pop-os/system76-oled
#
sub tuxedooledbrt() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages", 'L1');
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# deactivates apport reporting
#
sub apportfix() {
	my $module = shift;
	my $action = shift;
	my $oldApportLine = 'default=1';
	my $newApportLine = 'default=0';
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');

		if (isLineInFile('/etc/default/apport', 'enabled=1')) {
			$retval = substituteLineInFile('/etc/default/apport', 'enabled=1', 'enabled=0');
			if ($retval == 1) {
				printLog('apport has been disabled in /etc/default/apport', 'L0');
				#`service apport stop`;
				#printLog("service apport stop returned: $?");
				#`systemctl disable apport.service`;
				#printLog("systemctl disable apport.service returned: $?");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} elsif (isLineInFile('/etc/default/apport', 'enabled=0')) {
			printLog('apport was already disabled in /etc/default/apport', 'L1');
			#`service apport stop`;
			#printLog("service apport stop returned: $?");
			#`systemctl disable apport.service`;
			#printLog("systemctl disable apport.service returned: $?");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
		} else {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		}
	}
	if ($action eq 'upgrade') {
		# not neccessary
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}




###############################################################################
# Removes Linux device driver if installed and in configuration list
#
sub realtekr8125dkms() {
	my $module = shift;
	my $action = shift;
	# ignore if FAI or LiveISO install
	if ($FAI || $LiveISO) {
		return (1);
	}
	if ($action eq 'install') {
		printLog("package is obsolete", 'L1');
		$origConfModules{$module}{installed} = "no";
		$origConfModules{$module}{upgraded} = "no";
		$origConfModules{$module}{required} = "no";
	}
	if ($action eq 'upgrade') {
		printLog("package is obsolete", 'L1');
		$origConfModules{$module}{installed} = "no";
		$origConfModules{$module}{upgraded} = "no";
		$origConfModules{$module}{required} = "no";
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# Fixes backlight issue with BOE Model 2423 Serial Number 0 displays on
# - GMxNGxx
#
sub amdgpubacklightauxoff() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("amdgpu.backlight=0");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;	
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}




###############################################################################
# Fixes screen flickering when using some input devices
#
sub i915disablepsrfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("i915.enable_psr=0");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;	
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}



###############################################################################
# Provides better battery life
#
sub i915enablepsrfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("i915.tuxedo_disable_psr2=1");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		if (isTextInFile('/etc/default/grub', 'i915.enable_psr=0')) {
			replaceTextInFile('/etc/default/grub', 'i915.enable_psr=0', '');
		}
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;	
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		if (isTextInFile('/etc/default/grub', 'i915.enable_psr=0')) {
			replaceTextInFile('/etc/default/grub', 'i915.enable_psr=0', '');
		}
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}




###############################################################################
# Fixes unresponsive touchpad 
# - GMxTGxx
#
sub tuxedopinfixtgldkms() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1');
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# for reducing the timeout on loading the thunderbolt kernel module when
# booting the system
# - X170KM-G
#
sub thunderboltbootdelayfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("thunderbolt.tuxedo_icm_driver_ready_timeout=2000");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}



###############################################################################
# inserts a parameter to start lightdm after the windowmanager has started
#
sub lightdmlogindcheckgraphicalfix() {
	my $module = shift;
	my $action = shift;
	my $lightdmLine = 'logind-check-graphical=true';
	my $lightdmCheckGraphicalDir = '/etc/lightdm/lightdm.conf.d/';
	my $lightdmCheckGraphicalFile = $lightdmCheckGraphicalDir.'99_tuxedo.conf';

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		unless (-d $lightdmCheckGraphicalDir) {
			unless (mkdir $lightdmCheckGraphicalDir) {
				printLog("could not create directory $lightdmCheckGraphicalDir", 'TL0');
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
				return (0);
			}
		}
		if (-e $lightdmCheckGraphicalFile) {
			unless (isTextInFile($lightdmCheckGraphicalFile, '[LightDM]') && isTextInFile($lightdmCheckGraphicalFile, 'logind-check-graphical=true')) {
				if (createFile($lightdmCheckGraphicalFile, "[LightDM]\nlogind-check-graphical=true")) {
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
					addToConfiguredModules($module, "success");
				} else {
					$origConfModules{$module}{installed} = "failed";
					addToConfiguredModules($module, "failed");
					return (0);
				}
			}
		} else {
			if (createFile($lightdmCheckGraphicalFile, "[LightDM]\nlogind-check-graphical=true")) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
				return (0);
			}
		}
	}

	if ($action eq 'upgrade') {
		# not neccessary
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# For functioning backlight control on Nvidia GPU's
#
# - GMxTGxx
#
sub nvidiabacklightcontrolfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ("nvidia.NVreg_RegistryDwords=EnableBacklightHandler=0 nvidia.NVreg_RegistryDwords=EnableBrightnessControl=1 i915.enable_dpcd_backlight=0");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		if (isTextInFile('/etc/default/grub', ' NVreg_RegistryDwords=EnableBacklightHandler=0 NVreg_RegistryDwords=EnableBrightnessControl=1 i915.enable_dpcd_backlight=0')) {
			replaceTextInFile('/etc/default/grub', ' NVreg_RegistryDwords=EnableBacklightHandler=0 NVreg_RegistryDwords=EnableBrightnessControl=1 i915.enable_dpcd_backlight=0', ' nvidia.NVreg_RegistryDwords=EnableBacklightHandler=0 nvidia.NVreg_RegistryDwords=EnableBrightnessControl=1 i915.enable_dpcd_backlight=0');
		}
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeKernelParameters($module, @kernelParameters);
		}
	}
}



###############################################################################
# inserts a parameter to start lightdm after the windowmanager has started
#
sub earlyloadbacklightcontrolfix() {
	my $module = shift;
	my $action = shift;
	my $elbcLine = 'softdep nvidia pre: i915';
	my $elbcDir = '/etc/modprobe.d/';
	my $elbcFile = $elbcDir.'tuxedo_early_load_backlight_control_fix.conf';

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		unless (-d $elbcDir) {
			unless (mkdir $elbcDir) {
				printLog("could not create directory $elbcDir", 'TL0');
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
				return (0);
			}
		}
		if (-e $elbcFile) {
			unless (isTextInFile($elbcFile, $elbcLine)) {
				if (createFile($elbcFile, $elbcLine)) {
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
					addToConfiguredModules($module, "success");
				} else {
					$origConfModules{$module}{installed} = "failed";
					addToConfiguredModules($module, "failed");
					return (0);
				}
			}
		} else {
			if (createFile($elbcFile, $elbcLine)) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
				return (0);
			}
		}
	}

	if ($action eq 'upgrade') {
		# not neccessary
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# Installs the newest driver for RTL8125 2.5GbE Controller
# Solves some ethernet problems/hang/slow connection
#
sub r8125dkms() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $package_tuxedo_r8125_dkms;
	if ($action eq 'install') {
		# check if the package is already installed
		if( ! isPackageInstalled('tuxedo-r8125-dkms') ) {
			messageLongInstall();
			$wasInstalled = 0;
			$package_tuxedo_r8125_dkms = installPackage('tuxedo-r8125-dkms');
		} else {
			$package_tuxedo_r8125_dkms = 1;
		}

		if( $package_tuxedo_r8125_dkms ) {
			if ($wasInstalled) {
				printLog("$origConfModules{$module}{name} was already installed", 'L1');
				addToConfiguredModules($module, "nothingToDo");
			} else {
				addToConfiguredModules($module, 'success');
			}
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
		} else {
			$origConfModules{$module}{installed} = 'failed';
			addToConfiguredModules($module, 'failed');
		}
	}

	if ($action eq 'upgrade') {
		printLog('upgrade not necessary for packages', 'L1');
	}

	if ($action eq 'remove') {
		if (removeWarningMessage('')) {
			removeDebianModule($module, 1);
		}
	}
}



###############################################################################
# Forces cardreader Realtek RTS522A to stay on when device goes into idle
# - if USB device 0x10ec:0x522a detected
#
sub cardreaderfix() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $filename1 = '/etc/udev/rules.d/45-tuxedo-force-realtek-522a-cardreader-on.rules';
	my $niceTime = getBackupFileTime();
	my $fileText1 = "# added by tuxedo-tomte ".$niceTime."\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR{vendor}==\"0x10ec\", ATTR{device}==\"0x522a\", RUN+=\"/bin/sh -c 'echo on > /sys/bus/pci/devices/\$kernel/power/control'\"\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1');
		$retval1 = createFile($filename1, $fileText1, 1);
		if ($retval1 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'upgrade') {
		# not implemented yet
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0');
	}
}



###############################################################################
# Pulse gen 2 in combination with some Samsung SSDs do not wake up from sleep
# This workaround allows suspend (s2idle) wake-up to function
#
sub samsungnvmefix() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $filename = '/lib/udev/rules.d/99-pulse1502-samsung-nvme.rules';
	my $niceTime = getBackupFileTime();
	my $fileText = "# added by tuxedo-tomte ".$niceTime."\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR\{vendor}==\"0x144d\", ATTR\{device}==\"0xa80a\", RUN+=\"/bin/sh -c 'echo 0 | tee /sys/bus/pci/devices/\$kernel/d3cold_allowed'\"\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR\{vendor}==\"0x144d\", ATTR\{device}==\"0xa808\", RUN+=\"/bin/sh -c 'echo 0 | tee /sys/bus/pci/devices/\$kernel/d3cold_allowed'\"\n";
	if ($action eq 'install') {
		if (isLineInFile($filename, 'SUBSYSTEM=="pci", ACTION=="add", ATTR\{vendor}=="0x144d", ATTR\{device}=="0xa80a", RUN\+="\/bin\/sh -c \'echo 0 \| tee \/sys\/bus\/pci\/devices\/\$kernel\/d3cold_allowed\'"') &&
			isLineInFile($filename, 'SUBSYSTEM=="pci", ACTION=="add", ATTR\{vendor}=="0x144d", ATTR\{device}=="0xa808", RUN\+="\/bin\/sh -c \'echo 0 \| tee \/sys\/bus\/pci\/devices\/\$kernel\/d3cold_allowed\'"')) {
			printLog("entries for samsungnvmefix are already present", 'TL2');
			$localConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = "yes";
			$configuredModules{$module} = 'nothingToDo';
		} else {
			printLog("applying $origConfModules{$module}{name}", 'L1');
			$retval = createFile($filename, $fileText, 1);
			if ($retval == 0) {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1');
		$retval = createFile($filename, $fileText, 1);
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}










###############################################################################
###############################################################################
###############################################################################
# subs for tuxedorepos & tuxedomirrors
#

###############################################################################
# Adds the TUXEDO repos to the system with public key
# returns 2 if successful and changes to repos were made
# returns 1 if successful and no changes to repos
# returns 0 if failed
#
sub createRepos {
	my %repos = %{$_[0]};
	my %repoHash;
	my $key;
	my $DH;
	my $sourceline;
	my $modified = 0;
	my $sourcesListDir = '/etc/apt/';
	my $sourcesListDirD = '/etc/apt/sources.list.d/';
	my $sourcesFileName = $sourcesListDir.'sources.list';

	if (exists $repos{$completeDistVersion}{deb}) {
		printLog("deb repos detected", 'TL2');
		if (isLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', '^deb https?:\/\/testdeb.*')) {
			printLog('testing environment detected, leaving repos as they are', 'TL2');
			return (1);
		}
	} elsif (exists $repos{$completeDistVersion}{mirrors}) {
		printLog("mirror repos detected", 'TL2');
		if (isLineInFile('/etc/apt/sources.list', '^deb https?:\/\/testmirrors.*')) {
			printLog('testing environment detected, leaving repos as they are', 'TL2');
			return (1);
		}
	}

	if (!-d $sourcesListDir) {
		printLog("no $sourcesListDir found (something's really wrong)", 'TL0');
		# no apt directory, somethings fishy
		return (0);
	}
	if (!-d $sourcesListDirD) {
		printLog("no $sourcesListDirD found, creating one", 'TL0');
		mkdir($sourcesListDirD);
	}

	if (-e $sourcesFileName) {
		$repoHash{$sourcesFileName} = [readFileReturnLines($sourcesFileName)];
	}

	# read content from all files *.list into hash
	if (opendir($DH,$sourcesListDirD)) {
		while (readdir $DH) {
			if ( $_ =~ /.*\.list$/ ) {
				$sourcesFileName = $sourcesListDirD.$_;
				$repoHash{$sourcesFileName} = [readFileReturnLines($sourcesFileName)];
			}
		}
		closedir($DH);
	}

	# workaround for possible old entries in sources list
	if (($completeDistVersion ne 'TUXEDO_OS 22.04') && ($completeDistVersion ne 'Ubuntu 22.04') && ($completeDistVersion ne 'TUXEDO OS 22.04')) {
		if (isLineInFile('/etc/apt/sources.list.d/graphics-tuxedo.list', 'deb http://graphics.tuxedocomputers.com/ubuntu bionic main')) {
			substituteLineInFile('/etc/apt/sources.list.d/graphics-tuxedo.list', 'deb http://graphics.tuxedocomputers.com/ubuntu bionic main', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/oibaf-tuxedo.list', 'deb http://oibaf.tuxedocomputers.com/ubuntu bionic main')) {
			substituteLineInFile('/etc/apt/sources.list.d/oibaf-tuxedo.list', 'deb http://oibaf.tuxedocomputers.com/ubuntu bionic main', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', 'deb http://deb.tuxedocomputers.com/ubuntu bionic main')) {
			substituteLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', 'deb http://deb.tuxedocomputers.com/ubuntu bionic main', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/graphics-tuxedo.list', 'deb http://graphics.tuxedocomputers.com/ubuntu focal main')) {
			substituteLineInFile('/etc/apt/sources.list.d/graphics-tuxedo.list', 'deb http://graphics.tuxedocomputers.com/ubuntu focal main', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/oibaf-tuxedo.list', 'deb http://oibaf.tuxedocomputers.com/ubuntu focal main')) {
			substituteLineInFile('/etc/apt/sources.list.d/oibaf-tuxedo.list', 'deb http://oibaf.tuxedocomputers.com/ubuntu focal main', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', 'deb http://deb.tuxedocomputers.com/ubuntu focal main')) {
			substituteLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', 'deb http://deb.tuxedocomputers.com/ubuntu focal main', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/graphics-tuxedo.list', '# Added by TUXEDO Tomte')) {
			substituteLineInFile('/etc/apt/sources.list.d/graphics-tuxedo.list', '# Added by TUXEDO Tomte', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/oibaf-tuxedo.list', '# Added by TUXEDO Tomte')) {
			substituteLineInFile('/etc/apt/sources.list.d/oibaf-tuxedo.list', '# Added by TUXEDO Tomte', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', '# Added by TUXEDO Tomte')) {
			substituteLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', '# Added by TUXEDO Tomte', '');
		}
	} else {
		if (isLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', 'deb http://deb.tuxedocomputers.com/ubuntu jammy main')) {
			substituteLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', 'deb http://deb.tuxedocomputers.com/ubuntu jammy main', '');
		}
		if (isLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', '# Added by TUXEDO Tomte')) {
			substituteLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', '# Added by TUXEDO Tomte', '');
		}
		if (-e '/etc/apt/sources.list.d/graphics-tuxedo.list') {
			if (unlink('/etc/apt/sources.list.d/graphics-tuxedo.list')) {
				printLog('deleted /etc/apt/sources.list.d/graphics-tuxedo.list', 'TL1');
			}
		}
		if (-e '/etc/apt/sources.list.d/oibaf-tuxedo.list') {
			if (unlink('/etc/apt/sources.list.d/oibaf-tuxedo.list')) {
				printLog('deleted /etc/apt/sources.list.d/oibaf-tuxedo.list', 'TL1');
			}
		}
	}



	my $firstEntry;
	my $sourcesListBackedup = 0;
	foreach $key (keys %{ $repos{$completeDistVersion} }) {
		# each line
		if ($key ne 'name') {
			$firstEntry = 1;
			foreach (@{ $repos{$completeDistVersion}{$key}{content} }) {
				if (!isLinePresent($_, %repoHash)) {
					# make backup if file exists and is first entry into file
					if ( (-s $repos{$completeDistVersion}{$key}{filename}) && ($firstEntry == 1) ) {
						backupFile($repos{$completeDistVersion}{$key}{filename});
						$firstEntry = 0;
						if ($repos{$completeDistVersion}{$key}{filename} eq '/etc/apt/sources.list' ) {
							$sourcesListBackedup = 1;
						}
					}
					# create file + line
					if (! -e $repos{$completeDistVersion}{$key}{filename}) {
						createFile($repos{$completeDistVersion}{$key}{filename}, "# Added by TUXEDO Tomte\n$_\n", 1);
						printLog("new file: $repos{$completeDistVersion}{$key}{filename}", 'L0');
						printLog("added: $_", 'L0');
						$firstEntry = 0;
						$modified = 1;
					# or append line
					} else {
						appendFile($repos{$completeDistVersion}{$key}{filename}, "\n# Added by TUXEDO Tomte\n$_\n");
						printLog("append file: $repos{$completeDistVersion}{$key}{filename}", 'L0');
						printLog("added: $_", 'L0');
						$modified = 1;
					}
				}
			}
		}
	}
	return ($modified+1);
}




###############################################################################
# checks if filenames md5sum corresponds to the given checksum
# returns 1 if yes
# returns 0 if not or something went wrong
#
sub compareMD5sum {
	my ($filename, $givenHash) = (@_);
	my $hashFile;
	my $FH;
	my $data;
	if (-e $filename) {
		if (open($FH, '<', $filename)) {
			$data = <$FH>;
			close $FH;
			$hashFile = md5_hex($data);
			if ($givenHash eq $hashFile) {
				return (1);
			} else {
				return (0);
			}
		} else {
			printLog ("could not open file $filename", 'L0');
			return (0);
		}
	} else {
		printLog ("file $filename does not exist", 'L0');
		return (0);
	}
}



###############################################################################
# checks if the repo key is installed by comparing to given md5 checksum
# adds the repo key for TUXEDO repos if not present
#
sub addRepoKey {
	my $output;
	my $retval;
	my $errorCode;
	my $outputKey;
	# install TUXEDO keyring for repositories
	checkNetwork(10,10);
	unless (isPackageInstalled("tuxedo-archive-keyring")) {
		printLog("TUXEDO keyring is not installed", 'TL2');
		$outputKey = `wget -r -nd --no-parent -P /tmp/ -A 'tuxedo-archive-keyring*.deb' https://deb.tuxedocomputers.com/ubuntu/pool/main/t/tuxedo-archive-keyring/`;
		usleep(300000);
		unlockPackageManagement('apt-get keyring');
		$outputKey = `apt-get -y --allow-unauthenticated install /tmp/tuxedo-archive-keyring*`;
		lockPackageManagement();
		$errorCode = $?/256;
		if ($errorCode != 0) {
			printLog("error code apt-get: $errorCode", 'L2');
			printLog("output apt-get: $outputKey", 'L2');
		}
		if (isPackageInstalled("tuxedo-archive-keyring")) {
			printLog("TUXEDO keyring installed successfully", 'TL2');
		} else {
			printLog("TUXEDO keyring installation failed", 'TL2');
		}
	}
	return (1);
}



###############################################################################
# comment out anything else on sources.list which has
# deb mirrorurl and not tuxedocomputers
# returns 0 if nothing was changed
# returns 1 if modifications were made
#
sub cleanSourcesList {
	my $FHsource;
	my @sourcelines;
	my $sourceline;
	my $sourcesListFile = '/etc/apt/sources.list';
	my $modified = 0;
	# read all the lines
	if ( (-e $sourcesListFile) && open($FHsource, "<", $sourcesListFile)) {
		chomp(@sourcelines = <$FHsource>);
		close $FHsource;
		# open for writing
		if (!-e $sourcesListFile) {
			return (0);
		}
		if (open($FHsource, ">", $sourcesListFile)) {
			foreach $sourceline (@sourcelines) {
				if (setComment(\$sourceline)) {
					$modified = 1;
				}
				# no backup for the file as it only comments out lines
				print $FHsource "$sourceline\n";
			}
			close $FHsource;
		} else {
			printLog("file $sourcesListFile not found, this is bad and should not happen!!", 'L0');
		}
	} else {
		printLog("file $sourcesListFile not found, this is very bad and should not happen!!", 'L0');
	}
	return ($modified);
}


###############################################################################
# decides whether the line has to be commented out or not
# returns 0 if nothing changed
# returns 1 if commented out
# modifies the string given to the subroutine
#
sub setComment {
	my $repoline = shift;
	my $tmpline = $$repoline;
	my $FH;
	my @repolines;
	my $regExUbuntu = '^deb.*\.ubuntu\.com\/ubuntu.* '.$tuxedo_mirrors{$completeDistVersion}{name}.'.*$';
	my $regExElementaryOS = '^deb.*mirror:\/\/mirrors\.ubuntu\.com\/mirrors\.txt .* main restricted universe multiverse$';
	if ( (-e $reposList) && open($FH, '<', $reposList) ) {
		chomp(@repolines = <$FH>);
		close $FH;
	} else {
		printLog("Err: $!", 'L0');
		printLog("could not open repository mirrors list at $reposList", 'TL0', 'L0');
		return (0);
	}

	# don't check if TUXEDO testmirrors included for testing purposes
	if ($$repoline =~ /^deb https?:\/\/testmirrors\.tuxedocomputers\.com\/.*/) {
		printLog("found testmirror, not changing it", 'TL2');
		return (0);
	}

	if ( $$repoline =~ /^deb .*$tuxedo_mirrors{$completeDistVersion}{name}.*/ || $$repoline =~ m/$regExElementaryOS/ ) {
		# this is a repo line
		# if line matches some official debian country mirror & not tuxedo
		# delete old mirrors.tuxedocomputers.com urls
		if ( (($$repoline =~ m/$regExUbuntu/) && !($$repoline =~ m/https:\/\/mirrors\.tuxedocomputers.*main restricted universe multiverse/)) || $$repoline =~ m/^deb http:\/\/packages\.tuxedocomputers\.com\// || $$repoline =~ m/^deb http:\/\/mirrors\.tuxedocomputers\.com\// || $$repoline =~ m/$regExElementaryOS/) {
			$$repoline = "\n#### commented out by TUXEDO Tomte\n"."# $$repoline";
			printLog("commented out: $$repoline", 'L0');
			return (1);
		}
		# check for repos in comprehensive mirror list
		foreach (@repolines) {
			if ( $$repoline =~ /$_/ ) {
				# repo matches
				$$repoline = "\n#### commented out by TUXEDO Tomte\n"."# $$repoline";
				printLog("commented out: $$repoline", 'L0');
				return (1);
			}
		}
	} else {
		# nothing has to be done
		return (0);
	}
}



###############################################################################
# replaces "http" with "https" in the files given by a %hash
# returns 2 if something was changed
# returns 1 if nothing was changed
# returns 0 if there was an error
#
sub httpToHttps {
	my %repos = %{$_[0]};
	my $key;
	my $listFH;
	my @lines;
	my $returnValue = 0;
	foreach $key (keys %{ $repos{$completeDistVersion} }) {
		if ($key ne 'name') {
			if (-e $repos{$completeDistVersion}{$key}{filename}) {
				if (open($listFH, '<', $repos{$completeDistVersion}{$key}{filename})) {
					@lines = <$listFH>;
					close ($listFH);
					foreach (@lines) {
						if ($_ =~ /^deb http:/) {
							printLog("replacing in line: $_", 'TL2');
							$_ =~ s/^deb http:/deb https:/g;
							$returnValue = 2;
						}
					}
					if (open($listFH, '>', $repos{$completeDistVersion}{$key}{filename})) {
						print $listFH @lines;
						close($listFH);
					} else {
						printLog("can't open $repos{$completeDistVersion}{$key}{filename} for writing", 'TL0');
						return (0);
					}
				} else {
					printLog("can't open $repos{$completeDistVersion}{$key}{filename} for reading", 'TL0');
					return (0);
				}
			}
		}
	}
	return ($returnValue);
}




###############################################################################
# package handling
#

###############################################################################
# Deinstalls all packages beginning with a given string except the one given as
# second parameter
# returns 0 if the search for the packages failed or if the deinstallation was
# unsuccessful
# returns 1 if everything was ok, even if no packages were found
#
sub deinstExcept {
	my $deinst = shift;
	my $except = shift;
	my $searchCmd = $consoleLanguage."dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\' $deinst*"." 2>&1";
	my $retString = `$searchCmd`;
	printLog("first result for $deinst:\n$retString", 'L2');
	my $retValue = $?/256;
	my $deinstCmd;
	my $deinstKey;
	my $deinstList ='';
	if ($retValue != 0) {
		if ($retValue == 1) {
			printLog("no packages found matching search string to deinstall packages: $deinst with except pattern: $except", 'L1');
			return (1);
		}
		printLog('something went wrong while searching for packages', 'L1');
		return (0);
	}
	my %retHash = $retString =~ /(\S+)\s*(\S+)/g;

	if ($FAI) {
		$deinstCmd = $consoleLanguage.'apt-get -yq remove';
	} else {
		unlockPackageManagement('pkcon remove');
		$deinstCmd = $consoleLanguage.'pkcon -yp remove';
		lockPackageManagement();
	}
	my $deinstCounter = 0;

	foreach $deinstKey (keys %retHash) {
		if (($retHash{$deinstKey} =~ /i./) && !($deinstKey =~ $except)) {
			$deinstCounter++;
			$deinstCmd = $deinstCmd.' '.$deinstKey;
			$deinstList = $deinstList.' '.$deinstKey;
		}
	}
	if ($deinstCounter != 0) {
		printLog("deinstalling: $deinstList", 'L0');
		$deinstCmd = $deinstCmd.' >/dev/null 2>&1';
		unlockPackageManagement('pkcon remove');
		my $retText = `$deinstCmd`;
		lockPackageManagement();
		if ($? != 0) {
			$retValue = $?/256;
			printLog("failed to deinstall packages, retvalue: $retValue", 'L0');
			printLog("retText: $retText", 'L0');
			return (0);
		} else {
			printLog('deinstallation of packages successful', 'L1');
			return (1);
		}
	} else {
		printLog('nothing to deinstall', 'L1');
		return (1);
	}
}



###############################################################################
# Deinstalls all packages beginning with a given string
# uses '*' at end of package name to be searched
# returns 1 if the search for the packages failed or if the deinstallation was
# unsuccessful
# returns 0 if everything was ok, even if no packages were found
#
sub deinstallPackage {
	my $deinst = shift;
	my $deinstKey;
	my $deinstList = '';
	my $searchCmd = $consoleLanguage."dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\' $deinst*"." 2>&1";
	my $retString = `$searchCmd`;
	my $retValue = $?/256;
	if ($retValue != 0) {
		if ($retValue == 1) {
			printLog("no packages found matching search string to deinstall packages: $deinst", 'L1');
			return (0);
		}
		printLog("something went wrong while searching for packages: $deinst", 'L1');
		return (1);
	}
	my %retHash = $retString =~ /(\S+)\s*(\S+)/g;

	my $pkconDeinst = $consoleLanguage.'pkcon -yp remove';
	my $deinstCounter = 0;

	foreach $deinstKey (keys %retHash) {
		if ($retHash{$deinstKey} =~ /i./) {
			$deinstCounter++;
			$pkconDeinst = $pkconDeinst.' '.$deinstKey;
			$deinstList = $deinstList.' '.$deinstKey;
		}
	}
	if ($deinstCounter != 0) {
		printLog("deinstalling: $deinstList", 'L0');
		$pkconDeinst = $pkconDeinst.' >/dev/null 2>&1';
		unlockPackageManagement('pkcon remove');
		if (system($pkconDeinst)) {
			$retValue = $?/256;
			printLog("failed to deinstall packages, retvalue: $retValue", 'L0');
			return (1);
		} else {
			printLog('deinstallation of packages successful', 'L0');
			return (0);
		}
		lockPackageManagement();
	} else {
		printLog('nothing to deinstall', 'L0');
		return (0);
	}
}



###############################################################################
# Deinstalls a package
# returns 1 if the search for the packages failed or if the deinstallation was
# unsuccessful
# returns 0 if everything was ok, even if no package were found
#
sub deinstallSinglePackage {
	my $deinst = shift;
	my $pkconDeinst = 'pkcon -yp remove';
	my $retValue;

	$pkconDeinst = $pkconDeinst.' '.$deinst;
	printLog("deinstalling: $deinst", 'L0');
	$pkconDeinst = $pkconDeinst.' >/dev/null 2>&1';
	if (isPackageInstalled($deinst)) {
		unlockPackageManagement('pkcon deinst');
		if (system($pkconDeinst)) {
			$retValue = $?/256;
			printLog("failed to deinstall package, retvalue: $retValue", 'L0');
			return (1);
		} else {
			printLog('deinstallation of package successful', 'L0');
			return (0);
		}
		lockPackageManagement();
	} else {
		printLog("package $deinst was not found", 'L0');
	}
}





###############################################################################
# Checks if the package is installed on the system
# return 1 if yes
# return 0 if no
#
sub isPackageInstalled {
	my $package = shift;
	my $cmd = $consoleLanguage.'dpkg-query -W -f=\'${db:Status-Abbrev}\' '.$package.' 2>&1';
	my $retString = `$cmd`;
	my $retValue = $?/256;
	printLog("searching for package: $package\nanswer: $retString", 'L2');
	if ($retString =~ m/^[ih][i]\s$/) {
		printLog("package $package is installed: $retString", 'L1');
		return (1);
	} else {
		printLog("package $package is not installed: $retString", 'L1');
		return (0);
	}
}



###############################################################################
# installs a package by pkcon or apt-get
# returns 1 if successful
# returns 0 if package was not installed
#
sub installPackage {
	my $packageName = shift;
	my $retval;
	if ($FAI) {
		printLog("install package $packageName", 'TL0');
		# usefull debug option: Debug::pkgDPkgProgressReporting=true
		unlockPackageManagement("pkcon apt-get install $packageName");
		if ($logLevel > 1) {
			$retval = `apt-get -o Debug::pkgDPkgProgressReporting=true -y install $packageName`;
		} else {
			$retval = `apt-get -y install $packageName`;
		}
		lockPackageManagement();
		printLog("return from apt-get:\n$retval", 'TL2');
		$retval = isPackageInstalled($packageName);
	} else {
		printLog("install package $packageName", 'L0');
		checkNetwork(10,10);
		unlockPackageManagement("pkcon install $packageName");
		if ($logLevel > 1) {
			$retval = `pkcon -yp install $packageName >>$logFile 2>&1`;
		} else {
			$retval = `pkcon -yp install $packageName >/dev/null 2>&1`;
		}
		lockPackageManagement();
		printLog("return from pkcon:\n$retval", 'L2');
		$retval = isPackageInstalled($packageName);
		if ($retval == 0) {
			printLog("failed to install $packageName", 'L0');
			printLog("will try again later", 'L0');
			# repair a possibly wrecked package manager	
			unlockPackageManagement('dpkg configure');
			`dpkg --configure -a`;
			lockPackageManagement();
			startTomteDelayed();
		}
	}
	return $retval;
}



###############################################################################
# removes a package by pkcon or apt-get
# returns 1 if successful or not installed
# returns 0 if failed
#
sub removePackage {
	my $packageName = shift;
	my $retval;
	printLog("remove package $packageName", 'TL0');
	unlockPackageManagement("pkcon remove $packageName");
	$retval = `pkcon -yp remove $packageName >/dev/null 2>&1`;
	lockPackageManagement();
	printLog("return from pkcon:\n$retval", 'L2');
	$retval = isPackageInstalled($packageName);
	if ($retval == 1) {
		printLog("failed to remove $packageName", 'L0');
		printLog("will try again later", 'L0');
		startTomteDelayed();
		return (0);
	}
	return (1);
}


###############################################################################
# sets mark to auto or manual
# usage setAptMark('package_name','auto|manual')
# returns 1 if set 0 if not
#
sub setAptMark {
	my ($package, $mark) = @_;
	my $retVal;
	if ( `$consoleLanguage apt-mark showauto $package` =~ /$package/ ) {
		printLog("package is set to auto, changing to manual now", 'L1');
		$retVal = `$consoleLanguage apt-mark manual $package`;
		if ($retVal =~ /was already/) {
			return (0);
		} else {
			return (1);
		}
	}
	return (0);
}



###############################################################################
# installs a linux kernel from the name of the main metapackage
# installKernelFlavour('metapackageName', \$failed, \$somethingDone)
# reqires two parameters failed and nothingDone
# returns 0 if something went wrong
# returns 1 if subroutine run through
#
sub installKernelFlavour {
	my ($flavour, $failed, $somethingDone) = @_;
	printLog("installKernelFlavour flavour: $flavour failed: $failed somethingDone: $somethingDone", 'TL2');
	if (!(defined $failed)) {
		$failed = 0;
	}
	if (!(defined $somethingDone)) {
		$somethingDone = 0;
	}
	my $partialName;
	my $installCmd = 'apt-get install -yq ';
	my $testCmd = "dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\'";
	my $testCmd2 = $testCmd;
	my $retString;
	my $package;
	my $allPackagesInstalled = 1;
	my @lines;
	my $packageMissing = 0;
	my $errorCode;
	if (!(exists $flavours{$distributionVersion}{$flavour})) {
		printLog("flavour $flavour does not exist!!", 'TL0');
		$failed += 1;
		return (0);
	}
	$installCmd = $installCmd.$flavours{$distributionVersion}{$flavour}{'installPackages'}.' 2>&1';
	if (!populateFlavourPackages("$flavour")) {
		printLog("no packages found for kernel $flavour while installing, this is not good", 'L0');
		$failed += 1;
		return (0);
	}
	$testCmd = $testCmd.' '.join($", @{ $flavours{$distributionVersion}{$flavour}{'packages'}});

	foreach $package (@{ $flavours{$distributionVersion}{$flavour}{'packages'}}) {
		$testCmd2 = $testCmd2.' '.$package;
	}
	$testCmd2 = $testCmd2.' 2>&1';
	printLog("testcommand:\n$testCmd2", 'L2');
	$retString = `$testCmd2`;
	printLog("result:\n$retString", 'L2');
	@lines = split /\n/, $retString;
	foreach $package (@lines) {
		if (($package =~ /dpkg-query:/) || (!($package =~ /.*\s[ih][i]/))) {
			printLog("package missing: $package", 'L2');
			$packageMissing = 1;
		}
	}

	if ($packageMissing) {
		messageLongInstall();
		printLog("installing $flavour", 'L1');
		unlockPackageManagement('apt-get update and install kernel');
		`apt-get update -q`;
		$retString = `$installCmd`;
		lockPackageManagement();
		if ($retString =~ /dpkg --configure -a/) {
			printLog("some packages are not configured", 'L2');
			printLog("executing: make configure -a", 'L2');
			unlockPackageManagement('dpkg configure');
			`dpkg --configure -a`;
			lockPackageManagement();
			if ($? != 0) {
				$errorCode = $?/256;
				printLog("configure -a failed!! error code: $errorCode, exiting", 'L0');
				$failed += 1;
				return (0);
			} else {
				unlockPackageManagement('apt-get install kernel');
				$retString = `$installCmd`;
				lockPackageManagement();
			}
		}
		if ($? != 0) {
			$errorCode = $?/256;
			printLog("something went wrong while installing kernel packages", 'TL0');
			printLog("error: $errorCode", 'L0');
			printLog("$retString", 'L0');
		}
	
		$retString = `$testCmd`;
		printLog("check installed packages: \n$retString", 'L2');
		@lines = split /\n/, $retString;
		foreach (@lines) {
			if ($_ =~ /dpkg-query:/) {
				printLog("$_", 'L2');
				$allPackagesInstalled = 0;
			} elsif ($_ =~ /.*\s[ih][i]/) {
				/(\S+)\s*(\S+)/;
				printLog("$1 is installed", 'L2');
				$somethingDone += 1;
			}
		}
		if ($allPackagesInstalled) {
			printLog("kernel $flavour was installed correctly", 'L0');
		}
	}

	if (!$allPackagesInstalled) {
		$failed += 1;
	}
	printLog("failed: $failed, somethingdone: $somethingDone", 'L2');
	return (1);
}




###############################################################################
# uninstallAllOtherKernelFlavours($exceptKernel, \$failed, \$somethingWasDone)
# uninstall all other kernels except the one given
#
sub uninstallAllOtherKernelFlavours {
	my ($exceptKernel, $failed, $somethingWasDone) = @_;
	my $tempInstFailed = 0;
	my $tempInstDone = 0;
# 	if ($exceptKernel ne 'linux-generic') {
# 		uninstKernelFlavour('linux-generic',$exceptKernel, $tempInstFailed, $tempInstDone);
# 	}
# 	if ($exceptKernel ne 'linux-oem-20.04') {
# 		uninstKernelFlavour('linux-oem-20.04',$exceptKernel, $tempInstFailed, $tempInstDone);
# 	}
# 	if ($exceptKernel ne 'linux-oem-20.04-edge') {
# 		uninstKernelFlavour('linux-oem-20.04-edge',$exceptKernel, $tempInstFailed, $tempInstDone);
# 	}
# 	if ($exceptKernel ne 'linux-generic-hwe-20.04') {
# 		uninstKernelFlavour('linux-generic-hwe-20.04',$exceptKernel, $tempInstFailed, $tempInstDone);
# 	}
# 	if ($exceptKernel ne 'linux-generic-hwe-20.04-edge') {
# 		uninstKernelFlavour('linux-generic-hwe-20.04-edge',$exceptKernel, $tempInstFailed, $tempInstDone);
# 	}
# 	if ($exceptKernel ne 'linux-tuxedo-20.04') {
# 		uninstKernelFlavour('linux-tuxedo-20.04',$exceptKernel, $tempInstFailed, $tempInstDone);
# 	}
# 	if ($exceptKernel ne 'linux-tuxedo-20.04-edge') {
# 		uninstKernelFlavour('linux-tuxedo-20.04-edge',$exceptKernel, $tempInstFailed, $tempInstDone);
# 	}
# 	if ($exceptKernel ne 'linux-tuxedo-20.04-next') {
# 		uninstKernelFlavour('linux-tuxedo-20.04-next',$exceptKernel, $tempInstFailed, $tempInstDone);
# 	}
# 	uninstallRemnantKernels($exceptKernel, $tempInstFailed, $tempInstDone);
	$failed = $tempInstFailed;
	$somethingWasDone = $tempInstDone;
}





###############################################################################
# finds which main packages belong to the flavour and puts them into a list
# works only if packages are known or installed on the system
# returns 0 if something went wrong
# returns 1 if all is good
#
sub populateFlavourPackages {
	my $flavour = shift;
	my @packages;
	my $packageLine;
	my $searchCmd;
	my $result;
	my @lines;
	my $line;
	my $pkgString;
	printLog("populating $flavour", 'L2');
	$searchCmd = $consoleLanguage.'apt-cache depends --important '.$flavours{$distributionVersion}{$flavour}{'installPackages'};
	@packages = split(' ', $flavours{$distributionVersion}{$flavour}{'installPackages'});
	printLog("first searchcommand: $searchCmd", 'L2');
	$result = `$searchCmd`;
	printLog("first result:\n$result", 'L2');
	@lines = split /\n/, $result;
	foreach $line (@lines) {
		if ($line =~ /\s[\s|]Depends:\s[<]?([a-z0-9\-\_\.]+)[>]?/) {
			$pkgString = $1;
			if ($pkgString =~ /^linux-.*(?:image|headers|modules)-.*/) {
				printLog("Accepted: $pkgString", 'L2');
				$packageLine .= " $pkgString";
				push @packages, $pkgString;
			}
		}
	}
	if (@packages) {
		$searchCmd = $consoleLanguage.'apt-cache depends --important '.$packageLine;
		printLog("second searchcommand: $searchCmd", 'L2');
		$result = `$searchCmd`;
		printLog("second result:\n$result", 'L2');
		@lines = split /\n/, $result;
		foreach $line (@lines) {
			if ($line =~ /\s[\s|]Depends:\s[<]?([a-z0-9\-\_\.]+)[>]?/) {
				$pkgString = $1;
				if ($pkgString =~ /^linux-.*(?:image|headers|modules)-.*/) {
					printLog("Accepted: $pkgString", 'L2');
					push @packages, $pkgString;
				}
			}
		}
		@{ $flavours{$distributionVersion}{$flavour}{'packages'}} = uniq(@packages);
		printLog("packages found: @{ $flavours{$distributionVersion}{$flavour}{'packages'}}", 'L2');
	} else {
		printLog("empty package list for kernel $flavour while populating list, this should not happen!", 'L0');
		return (0);
	}
	return (1);
}



###############################################################################
# receives an array
# returns an array where all values are unique
#
sub uniq {
	my %seen;
	return grep { !$seen{$_}++ } @_;
}



###############################################################################
# deinstalls flavourToUninstall, keeps flavourNotToBeUninstalled
# modifies failed and somethingWasDone
# uninstKernelFlavour($flavourToDeinstall, $flavourNotToBeDeinstalled, \$failed, \$somethingWasDone)
# failed = 0 if everything went well (kernel uninstalled)
# failed = 1 if something could not be uninstalled
# somethingWasDone = 0 if no packages were uninstalled
# somethingWasDone = 1 if at least some package was uninstalled
# takes care not to uninstall any package from flavourNotBeUninstalled
# returns 0 if something went wrong
# returns 1 if subroutine run through
#
sub uninstKernelFlavour {
	my ($kernelToDelete, $kernelToKeep, $failed, $somethingWasDone) = @_;
	my $retString;
	my $searchCmd = $consoleLanguage."dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\' ";
	my @lines;
	my %pkgsHash;
	my $deinstString = $consoleLanguage.'apt-get remove -yq --purge';
	my $package;
	my $kernelModuleName;

	# find installed packages
	if (!(exists $flavours{$distributionVersion}{$kernelToDelete})) {
		printLog("flavour $kernelToDelete does not exist!!", 'TL0');
		$failed += 1;
		return (0);
	}
	if (!(exists $flavours{$distributionVersion}{$kernelToKeep})) {
		printLog("flavour $kernelToKeep does not exist!!", 'TL0');
		$failed += 1;
		return (0);
	}

	printLog("uninstKernel: $kernelToDelete keep: $kernelToKeep", 'L2');
	if (!populateFlavourPackages("$kernelToDelete")) {
		printLog("no packages found for kernel $kernelToDelete while uninstalling", 'L0');
		return (0);
	}
	$flavours{$distributionVersion}{$kernelToDelete}{'deletePackages'} = $flavours{$distributionVersion}{$kernelToDelete}{'installPackages'};
	foreach $package (@{ $flavours{$distributionVersion}{$kernelToDelete}{'packages'}}) {
		if (($package =~ /^linux-.*(?:image|modules)-.*/) && !(grep(/^$package$/, @{ $flavours{$distributionVersion}{$kernelToKeep}{'packages'}}))) {
			printLog("accepted: $package", 'L2');
			$flavours{$distributionVersion}{$kernelToDelete}{'deletePackages'} .= " $package";
		}
	}
	printLog("packages to delete: $flavours{$distributionVersion}{$kernelToDelete}{'deletePackages'}", 'L2');
	$searchCmd .= $flavours{$distributionVersion}{$kernelToDelete}{'deletePackages'}.' 2>&1';
	# find which packages are installed
	printLog('find which packages are installed', 'L2');
	$retString = `$searchCmd`;
	printLog("return values:\n$retString", 'L2');
	@lines = split /\n/, $retString;
	foreach (@lines) {
		if ((!($_ =~ /dpkg-query:/)) && ($_ =~ /.*\s[uirp][cHUFWti]/)) {
			/(\S+)\s*(\S+)/;
			$pkgsHash{$1} = $2;
		}
	}

	# deinstall found packages
	if ((keys %pkgsHash) != 0) {
		messageLongInstall();
		printLog("kernel packages to deinstall found", 'L1');
		foreach $package (keys %pkgsHash) {
			$deinstString .= ' '.$package;
		}
		$deinstString .= ' 2>&1';
		printLog("uninstalling $kernelToDelete", 'L0');
		printLog("deinstallation command: $deinstString", 'L2');
		# circumvent Ubuntu failsafe for currently installed kernel
		if ($deinstString =~ /$kernelRelease/) {
			printLog("deinstalling current kernel!", 'L2');
			$restartSystem = 1;
			rename '/usr/bin/linux-check-removal', '/usr/bin/linux-check-removal.orig';
			my $fileText = "#!/bin/sh\nexit 0";
			createFile('/usr/bin/linux-check-removal', $fileText, 1);
			chmod 755, '/usr/bin/linux-check-removal';
			unlockPackageManagement('apt-get remove kernel');
			$retString = `$deinstString`;
			lockPackageManagement();
			if ($retString =~ /sudo dpkg --configure -a/) {
				printLog("some packages are not configured", 'L2');
				printLog("executing: dpkg --configure -a", 'L2');
				unlockPackageManagement('dpkg configure');
				`dpkg --configure -a`;
				lockPackageManagement();
				if ($? != 0) {
					printLog("configure -a failed!! exiting", 'L2');
					$failed += 1;
					return (0);
				} else {
					unlockPackageManagement('apt-get remove kernel');
					$retString = `$deinstString`;
					lockPackageManagement();
				}
			}
			unlink '/usr/bin/linux-check-removal';
			rename '/usr/bin/linux-check-removal.orig', '/usr/bin/linux-check-removal';
			printLog("current kernel $kernelToDelete deinstalled", 'L0');
		} else {
			printLog("deinstallation command: $deinstString", 'L2');
			unlockPackageManagement('apt-get remove kernel');
			$retString = `$deinstString`;
			lockPackageManagement();
		}
		printLog("return: $retString", 'L2');
		if ($? != 0) {
			printLog("error: $?", 'L0');
		} else {
			printLog('no error from deinstall', 'L1');
		}

		# check whether packages have been deinstalled
		foreach $package (keys %pkgsHash) {
			printLog("package: $package", 'L2');
			if (isPackageInstalled($package)) {
				printLog("unwanted package $package is still installed", 'L0');
				$failed += 1;
			} else {
				$somethingWasDone += 1;
			}
		}
		if ($failed == 0) {
			$kernelModuleName = getSubName($kernelToDelete);
			if ($somethingWasDone > 0) {
				printLog("packages for $kernelToDelete were uninstalled", 'L2');
			}
			printLog("no packages for $kernelToDelete present", 'L0');
			if ($kernelModuleName ne '') {
				printLog("remove $kernelModuleName from origConfModules", 'L2');
				$origConfModules{$kernelModuleName}{installed} = 'no';
				$origConfModules{$kernelModuleName}{upgraded} = 'no';
				$localConfModules{$kernelModuleName}{installed} = 'no';
				return (1);
			}
		}
		return (0);
	} else {
		$kernelModuleName = getSubName($kernelToDelete);
		printLog("no packages to uninstall found for $kernelToDelete", 'L2');
		if ($kernelModuleName ne '') {
			printLog("remove $kernelModuleName from origConfModules", 'L2');
			$origConfModules{$kernelModuleName}{installed} = 'no';
			$origConfModules{$kernelModuleName}{upgraded} = 'no';
			$localConfModules{$kernelModuleName}{installed} = 'no';
			return (1);
		}
	}
	return (0);
}



###############################################################################
# uninstalls remnant kernels not connected with the desired metapackage
# returns 1 if all were uninstalled or no packages found
# returns 0 if something failed
# 
sub uninstallRemnantKernels {
	my ($kernelToKeep, $failed, $somethingWasDone) = @_;
	my $searchCmd = $consoleLanguage."dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\' linux-image-* linux-modules-* 2>&1";
	my $retString;
	my @lines;
	my @removePackages;
	my $package;
	my $line;
	my $deinstString = $consoleLanguage.'apt-get remove -yq --purge ';
	$retString = `$searchCmd`;
	printLog("result query remnant linux kernels:\n$retString", 'L2');
	@lines = split /\n/, $retString;
	foreach $line (@lines) {
		if ((!($line =~ /dpkg-query:/)) && ($line =~ /.*\s[uirp][cHUFWti]/)) {
			$line =~ /(\S+)\s*(\S+)/;
			$package = $1;
			if (($package =~ /^linux-.*(?:image|modules)-.*/) && !(grep(/^$package$/, @{ $flavours{$distributionVersion}{$kernelToKeep}{'packages'}}))) {
				printLog("accepted: $package", 'L2');
				push(@removePackages, $package);
			} else {
				printLog("rejected: $package", 'L2');
			}
		}
	}
	$package = '';
	if (scalar(@removePackages) > 0) {
		$deinstString .= join(' ', @removePackages).' 2>&1';
		printLog("deinstallation command: $deinstString", 'L2');
		unlockPackageManagement('apt-get remove remnant kernel');
		$retString = `$deinstString`;
		lockPackageManagement();
		printLog("deinstallation result: $retString", 'L2');
		if ($? != 0) {
			printLog("error: $?", 'L0');
		} else {
			printLog('no error from deinstall', 'L1');
		}
		# check whether packages have been deinstalled
		foreach $package (@removePackages) {
			printLog("test package: $package", 'L2');
			if (isPackageInstalled($package)) {
				printLog("unwanted package $package is still installed", 'L0');
				$failed += 1;
			} else {
				$somethingWasDone += 1;
			}
		}
		if (($failed == 0) && ($somethingWasDone > 0)) {
			printLog("all remnant kernel packages uninstalled", 'L0');
			return (1);
		} elsif ($failed == 0) {
			printLog("no remnant kernel packages to uninstall found", 'L1');
			return (1);
		} else {
			printLog("error in uninstalling remnant kernel packages", 'L1');	
			return (0);
		}

	} else {
		printLog("no remnant kernel packages to uninstall found", 'L1');
		return (1);
	}
}



###############################################################################
# removes a module containing a debian pakage
# removeDebianModule(module, restart)
# module is the short modulename
# if restart = 0 => don't restart
# if restart = 1 => restart
# checks if the package is installed
#
sub removeDebianModule {
	my ($module, $restart) = (@_);
	if (isPackageInstalled($origConfModules{$module}{name})) {
		if (removePackage($origConfModules{$module}{name})) {
			addToConfiguredModules($module, "removed");
			$origConfModules{$module}{installed} = "no";
			$origConfModules{$module}{upgraded} = "yes";
			$origConfModules{$module}{required} = "no";
			if ($restart) {
				$restartSystem = 1;
			}
		} else {
			addToConfiguredModules($module, "remove failed");
			$origConfModules{$module}{installed} = "remove failed";
			$origConfModules{$module}{version} = $localConfModules{$module}{version};
			$origConfModules{$module}{hwid} = $localConfModules{$module}{hwid};
		}
	} else {
		printLog("$origConfModules{$module}{name} is not installed, which is the desired result", 'TL0');
		addToConfiguredModules($module, "nothingToDo");
		$origConfModules{$module}{installed} = "no";
		$origConfModules{$module}{upgraded} = "yes";
		$origConfModules{$module}{required} = "no";
	}
}




###############################################################################
# removes kernel parameter from grub
# removeKernelParameters($module, @kernelParamaters)
# returns amount of parameters found
# returns 0 if nothing found or changed
#
sub removeKernelParameters {
	my ($module, @parameters) = @_;
	my $parameter;
	my $GF;
	my @grubLines;
	my $line;
	my $counter = 0;
	if ((-r $grubFile) && (open($GF, '<', $grubFile))) {
		chomp(@grubLines = <$GF>);
		close($GF);
		if ((-w $grubFile) && (open($GF, '>', $grubFile))) {
			foreach $line (@grubLines) {
				if ($line =~ /^GRUB_CMDLINE_LINUX_DEFAULT="/) {
					foreach $parameter (@parameters) {
						printLog("removing kernel parameter: $parameter", 'L2');
						if ($line =~ /^GRUB_CMDLINE_LINUX_DEFAULT="(|.* )$parameter( .*|)"/) {
							$line =~ s/$parameter//;
							$line =~ s/ +/ /g;
							$line =~ s/=" /="/;
							$line =~ s/ "$/"/;
							++$counter;
						}
					}
				}
				print $GF "$line\n";
			}
			close($GF);
			addToConfiguredModules($module, "removed");
			$origConfModules{$module}{installed} = "no";
			$origConfModules{$module}{upgraded} = "yes";
			$origConfModules{$module}{required} = "no";
			if ($counter > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
			}
			return ($counter);
		} else {
			printLog("could not open and write $grubFile", 'TL0');
			addToConfiguredModules($module, "remove failed");
			$origConfModules{$module}{installed} = "remove failed";
			$origConfModules{$module}{version} = $localConfModules{$module}{version};
			$origConfModules{$module}{hwid} = $localConfModules{$module}{hwid};
			return (0);
		}
	} else {
		printLog("could not open and read $grubFile", 'TL0');
		addToConfiguredModules($module, "remove failed");
		$origConfModules{$module}{installed} = "remove failed";
		$origConfModules{$module}{version} = $localConfModules{$module}{version};
		$origConfModules{$module}{hwid} = $localConfModules{$module}{hwid};
		return (0);
	}
	return (0);
}




###############################################################################
# creates file with content
# createFile( filename, text, backup )
# $backup accepts 0 and 1
# returns '1' if successfull, '0' if not
# 
sub createFile {
	my ($filename, $fileText, $backup) = @_;
	my $FH;
	if ( open($FH, ">",$filename) ) {
		print $FH "$fileText";
		close $FH;
		return (1);
	} else {
		printLog("Err: $!", 'L0');
		printLog("can't open $filename for writing", 'TL0');
		return (0);
	}
}



###############################################################################
# appends text to the file
# 
sub appendFile {
	my $filename = shift;
	my $fileText = shift;
	my $FH;
	if ( open($FH, ">>",$filename) ) {
		print $FH "$fileText";
		close $FH;
		return (1);
	} else {
		printLog("Err: $!", 'L0');
		printLog("can't open $filename for writing", 'TL0');
		return (0);
	}
}



###############################################################################
# backups file with timestamp
# 
sub backupFile {
	my $filename = shift;
	my $backupFile = $filename.'_'.getBackupFileTime().'.bak';
	if (copy($filename, $backupFile)) {
		printLog("created backup for $filename", 'TL');
		return (1);
	} else {
		printLog("Err: $!", 'L0');
		printLog("can't create backup file for $filename", 'TL0');
		return (0);
	}
}



###############################################################################
# checks if the line exists in the files given as hash
# 
sub isLinePresent {
	my $line = shift;
	my (%hash) = @_;
	my $filenameKey;
	foreach $filenameKey (keys %hash) {
		foreach (@{ $hash{$filenameKey} }) {
			if ($line eq $_) {
				return (1);
			}
		}
	}
	return (0);
}



###############################################################################
# substituteFileInLine('filename', 'string1', 'string2')
# substitutes a line in 'file' as 'string1' with 'string2
# returns 0 if line is already there
# returns 1 if successful (line was modified)
# returns -1 if something went wrong
# 
sub substituteLineInFile {
	my $filename = shift;
	my $origLine = shift;
	my $substLine = shift;
	my @fileLines;
	my $FH;

	if ( (-e $filename) && open($FH, "<", $filename) ) {
		while (<$FH>) {
			push (@fileLines, $_);
		}
		close $FH;
	} else {
		printLog("Err: $!", 'L0');
		printLog("no $filename present or unable to open the file for reading", 'L0');
		return (-1);
	}

	foreach( @fileLines ) {
		if ( $_ =~ /^$origLine$/ ) {
			$_ = "$substLine\n";
		}
	}
	if ( open($FH, ">", $filename) ) {
		print $FH @fileLines;
		close ($FH);
		return (1);
    } else {
		printLog("Err: $!", 'L0');
		printLog("no $filename present or unable to open the file for writing", 'L0');
		return (-1);
    }

	return (0);
}



###############################################################################
# isLineInFile('filename', 'string')
# matches a line with the 'string' as RegEx(!!!) and returns
# 1 if found
# 0 if not found or failed to open file
#
sub isLineInFile {
	my $filename = shift;
	my $match = shift;
	if ( (-e $filename) && open(FH, '<', $filename) ) {
		while( <FH> ) {
			if ( $_ =~ /^$match$/) {
				return (1);
			}
		}
	} else {
		printLog("can't open file $filename", 'L0');
	}
	return (0);
}



###############################################################################
# isTextInFile('filename', 'string')
# matches a line with the 'string' and returns
# 1 if found
# 0 if not found or failed to open file
#
sub isTextInFile {
	my $filename = shift;
	my $match = shift;
	if ( (-e $filename) && open(FH, '<', $filename) ) {
		while( <FH> ) {
			if ( $_ =~ /$match/) {
				return (1);
			}
		}
	} else {
		printLog("can't open file $filename", 'L0');
	}
	return (0);
}




###############################################################################
# replaceTextInFile('filename', 'string', 'replacement')
# replaces a text 'string' in file 'filename' with 'replacement'
# 1 if replaced
# 0 if not found
# -1 if failed to open or write file
#
sub replaceTextInFile {
	my ($filename, $match, $replace) = @_;
	my @lines;
	my $found = 0;
	if ( (-e $filename) && open(FH, '<', $filename) ) {
		@lines = <FH>;
		close(FH);
		foreach(@lines) {
			if ($_ =~ /$match/) {
				$_ =~ s/$match/$replace/;
				$found = 1;
			}
		}
		if ($found) {
			if (!-e $filename) {
				return (-1);
			}
			if ( open(FH, '>', $filename) ) {
				print FH @lines;
				close(FH);
				return (1);
			} else {
				return (-1);
			}
		} else {
			return (0);
		}
	} else {
		printLog("can't open file $filename", 'L0');
		return (-1);
	}
	return (-1);
}




###############################################################################
# returns 1 if active interface found
# returns 0 if none found
sub networkStatus {
	my $dirHandle;
	my $interfacesDir = '/sys/class/net';
	if ( !opendir ($dirHandle, $interfacesDir)) {
		printLog("unable to open $interfacesDir: $!", 'L0');
		return (0);
	}
	my @FILES = grep { $_ ne '.' && $_ ne '..' && $_ ne 'lo' } readdir($dirHandle);
	if (scalar(@FILES) < 1) { return (0); }
	foreach my $file (@FILES) {
		if (readFileReturnLine("$interfacesDir/$file/operstate") eq 'up' ) {
			return (1);
		}
	}
	return (0);
}



###############################################################################
# waitForNetwork('number of tries', 'wait seconds')
# polls for a network interface for status up
# tries 'number of tries' times and waits in between for 'wait seconds' seconds
# returns 1 if network is active
# returns 0 if network not active
sub waitForNetwork {
	my $triesNbr = shift;
	my $wait = shift;
	for ( my $i=1; $i<=$triesNbr; $i++ ) {
		if (networkStatus()) { return (1); }
		printLog("waiting for network: $i of $triesNbr");
		sleep ($wait);
	}
	return (0);
}




###############################################################################
# waitForNetwork('number of tries', 'wait seconds')
sub checkNetwork {
	my $triesNbr = shift;
	my $wait = shift;
	if ( (! $FAI) && (! $networkSearchDone) ) {
		if (waitForNetwork($triesNbr, $wait)) {
			$networkSearchDone = 1;
			printLog('found network !', 'L1');
		} else {
			$networkSearchDone = 1;
			printLog('no network found !! some fixes might not be applied correctly', 'L0');
		}
	}
}




###############################################################################
# inserts array values as kernel parameters if not present
# example: my $retval = insertGrub(\@kernelParameters);
# returns number of inserted parameters
# return value of -1 means it failed
#
sub insertGrub {
    my $grubFH;
    my @grubLines;
	my $module = shift;
    my $parameters = shift;
    my $parameter;
	my $inserted = 0;

	if ( (-e $grubFile) && open($grubFH, "<", $grubFile) ) {
		while (<$grubFH>) {
	    	push (@grubLines, $_);
		}
		close $grubFH;
    } else {
		printLog("Err: $!", 'L0');
		printLog("no $grubFile present or unable to open the file for reading", 'L0');
		return (-1);
    }

    foreach( @grubLines ) {
		# find the correct line
		if ( $_ =~ /^GRUB_CMDLINE_LINUX_DEFAULT="/ ) {
			foreach $parameter ( @{$parameters} ) {
				if (insertGrubParameter(\$_, \$parameter)) {
					++$inserted;
				}
			}
		}
    }

	# write the changes into grub config
    if ( open($grubFH, ">", $grubFile) ) {
		print $grubFH @grubLines;
		close ($grubFH);
    } else {
		printLog("Err: $!", 'L0');
		printLog("no $grubFile present or unable to open the file for writing", 'L0');
		return (-1);
    }
    return $inserted;
}


###############################################################################
# inserts a parameter into a grub line
# if the parameter is not present yet
# returns 1 if parameter inserted
# returns 0 if parameter already present
#
sub insertGrubParameter {
	my ($line, $parameter) = @_;

	if ($$line =~ /$$parameter/) {
		return (0);
	}
	if ($$line =~ /""/) {
		$$line =~ s/^(GRUB_CMDLINE_LINUX_DEFAULT=".*)"\n/$1$$parameter"\n/;
		printLog("inserted '$$parameter' into grub line", 'L1');
		return (1);
	} else {
		$$line =~ s/^(GRUB_CMDLINE_LINUX_DEFAULT=".*)"\n/$1 $$parameter"\n/;
		printLog("inserted '$$parameter' into grub line", 'L1');
		return (1);
	}
}




###############################################################################
# send message to desktop
# returns 1 if message was sent
# returns 0 if message could not be delivered for any reason
# icon:
# 	dialog-warning
# 	dialog-error
# 	dialog-information
# 	freedesktop.org
# urgency:
# 	0 : Low
# 	1 : Normal
# 	2 : Critical
#
sub messageDesktop {
	my $summary = shift;
	my $body = shift;
	my $urgency = shift;
	my $icon = shift;

	my $mUsername = '';
	my $mPid = '';
	my $mLine = '';
	my @whoLines = `who -u`;
	my $environ = '/proc/$mPid/environ';

	# don't message the desktop if LiveISO or FAI
	if ($LiveISO || $FAI) {
		return (0);
	}

	foreach $mLine (@whoLines) {
		if ($mLine =~ /\(:\d+\)/) {
			$mLine =~ /^(\w*).*\s(\d*)\s.*/;
			$mUsername = $1;
			$mPid = $2;
		}
	}
	if (($mUsername eq '') || ($mPid eq '')) {
		printLog('No display for message output found', 'L1');
		return (0);
	}

	my $dbusAddress;

	if ( (-e $environ) && open(FH, "<", $environ) ) {
		$dbusAddress = do { local $/; <FH> };
		close FH;
	} else {
		printLog('No display for message output found', 'L1');
		return (0);
	}
	
	$dbusAddress =~ /.*?(DBUS_SESSION_BUS_ADDRESS=unix:path=\/run\/user\/\d*\/bus).*/;
	$dbusAddress = $1;
	if ($dbusAddress eq '') {
		printLog('No display for message output found', 'L1');
		return (0);
	}

	my $mCmd = $consoleLanguage."sudo -u $mUsername $dbusAddress gdbus call --session --dest=org.freedesktop.Notifications --object-path=/org/freedesktop/Notifications --method=org.freedesktop.Notifications.Notify \"TUXEDO Tomte\" $sessionID \"$icon\" '$summary' '$body' '[]' '{\"urgency\": <$urgency>, \"desktop-entry\": <\"tuxedo-control-center\">}' 5000";

	`$mCmd`;

	if ($? != 0) {
		printLog('No display for message output found', 'L1');
		return (0);
	}
	return (1);
}



###############################################################################
# prints a message on display informing about an expected long install time
# does nothing if the message was already sent
#
sub messageLongInstall {
	if (($longInstall == 0) && (triesAlreadyDone() < 1)) {
		if (messageDesktop('TUXEDO Tomte is installing fixes','Please do not restart or shutdown the system.', 2, 'dialog-warning')) {
			$longInstall = 1;
		}
	}
}


###############################################################################
# initialize logFile
# create one if not existing already
# exits program if logfile can not be created
#
sub initLogging {
	my %options;
	@options{"configure", "reconfigure", "remove", "block", "unblock", "update"} = ();

	# do not log if no arguments
	if ($argValue{command} eq '') {
		return;
	}
	# do not log if false arguments
	if (! (exists $options{$argValue{command}})) {
		return;
	}

	# check if root permissions available
	if (! isRoot()) {
		return;
	}

	my $timestamp;
	# create logDir if it does not exist
	unless ( -d $logDir ) {
		mkdir($logDir, 0755);
		unless ( -d $logDir ) {
			$noLogFile = 1;
			print "Could not create $logDir\n";
			return;
		}
	}
	# check for logfile
	if ( -e $logFile ) {
		# append if logFile exists
		if ( open($LOGFILE, '>>', $logFile) )
		{
			$noLogFile = 0;
			$timestamp = getLoggingTime();
			close $LOGFILE;
			printLog('starting Tomte', 'L1');
			if ($FAI) {
				printLog('in FAI mode', 'L1');
			}
			return;
		} else {
			printLog("Err: $!", 'L1');
			$noLogFile =1;
			print "Could not open logFile $logFile\n$!\n";
			exit (0);
		}
	} else {
		# create a new logFile
		if ( open($LOGFILE, '>'.$logFile) ) {
			$noLogFile = 0;
			$timestamp = getLoggingTime();
			close $LOGFILE;
			printLog('starting Tomte', 'L1');
			if ($FAI) {
				printLog('in FAI mode', 'L1');
			}
			return;
		} else {
			printLog("Err: $!", 'L0', 'L1');
			$noLogFile =1;
			print "Could not create logFile $logFile\n";
			exit (0);
		}
	}
}



###############################################################################
#
sub getLoggingTime {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $nice_timestamp = sprintf ( "%04d%02d%02d %02d:%02d:%02d",
									$year+1900,$mon+1,$mday,$hour,$min,$sec);
	return $nice_timestamp;
}



###############################################################################
#
sub getBackupFileTime {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $nice_timestamp = sprintf ( "%04d%02d%02d%02d%02d%02d",
									$year+1900,$mon+1,$mday,$hour,$min,$sec);
	return $nice_timestamp;
}



###############################################################################
# prints into logFile or to terminal
# printLog('message', 'tlX')
# it assumes 'l' or 'L' if 't', 'T', 'L' or 'l' are ommited
# loglevels for X:
# 0 highest/errors/fatal
# 1 normal
# 2 debug
#
sub printLog {
	my ($message, $type) = @_;
	if ((!defined($type)) || ($type eq '')) {
		$type = 'L1';
	}
	my $level = $type;
	if ($level =~ /[0-2]/) {
		$level =~ s/\D//g;
		$level += 0;
	} else {
		$level = 1;
		$level += 0;
	}
	if ($type =~ /[LlTt]/) {
		$type =~ s/[\W\d]//g;
	} else {
		$type = 'L';
	}

	if ($FAI) {
		print "$message\n";
	} elsif ($level <= $logLevel) {
		if ((!$noLogFile) && ($type =~ /L/i)) {
			if (open($LOGFILE, '>>', $logFile) ) {
				my $timestamp = getLoggingTime();
				print $LOGFILE "$timestamp $message\n";
				close $LOGFILE;
			}
		}
		if ($type =~ /T/i) {
			print "$message\n";
		}
	}
}



###############################################################################
# fills global variable %localConfModules with data from $configFile
# if there is no configFile then it is left empty
# returns '0' if configfile can not be read, else returns '1'
#
sub readConfigFile {
	my %comp;
	my $FH;
	my $shortname;
	if ( (-e $configFile) && open($FH, '<', $configFile) ) {
		while ( my $line=<$FH> ) {
			chomp $line;
			# ignore comments
			if ($line =~ /^#/) {
				next;
			}
			# ignore empty lines
			if ($line =~ /^(\s)*$/) {
				next;
			}
			# check data format
			if (validConfigLine($line)) {
				my ($name, @cols) = split /\s+/, $line;
				# check if module name exists in orig and return shortname
				$shortname = validModuleName($name);
				if ($shortname ne '') {
					# @comp values have to be same as in writeConfigFile
					@comp{qw(name version installed blocked required hwid)} = ($name, @cols);

					$localConfModules{$shortname} = { %comp };
					# convert to numbers
					$localConfModules{$shortname}{version} = $localConfModules{$shortname}{version} * 1;
					$localConfModules{$shortname}{hwid} = $localConfModules{$shortname}{hwid} * 1;
				} else {
					printLog("module: $name does not exist", 'L1');
				}
			} else {
				printLog("invalid line in $configFile", 'L0');
			}
		}
		close $FH;
	} else {
		printLog("Err: $!", 'L0');
		printLog("could not open configFile: $configFile $!", 'TL0');
		return (0);
	}
	return (1);
}


###############################################################################
# checks if the line has valid values
# return 0 if invalid, 1 if valid
#
sub validConfigLine {
	my $line = shift;
	# name version installed blocked required hwid
	if ($line =~ /^[a-zA-Z0-9\-\.]+\s[a-zA-Z0-9\-]\s(yes|no|failed)\s(yes|no)\s(yes|no|prerequisite)\s[a-zA-Z0-9\-]\s*$/) {
		return (1);
	} else {
		printLog("found invalid configuration line in $configFile:\n$line", 'L0');
		return (0);
	}
}



###############################################################################
# overwrites $configFile with data from $origConfModules if it does not exist
#
sub writeConfigFile {
	my $FH;
	my $installed;
	my $version;
	my $hwid;
	if ( open($FH, '>', $configFile) ) {
		printLog("writing configfile", 'L1');
		print $FH "# name version installed blocked required hwid\n";
		foreach my $name (sort keys %origConfModules) {
			# values have to be same as in readConfigFile
			if ($origConfModules{$name}{required} ne 'no') {
				if ($origConfModules{$name}{upgrade} eq 'yes') {
					# upgrade available
					if ($origConfModules{$name}{upgraded} eq 'yes') {
						# upgrade was executed
						$version = $origConfModules{$name}{version};
						$hwid = $origConfModules{$name}{hwid};
						$installed = $origConfModules{$name}{installed};
					} else {
						# upgrade was not executed
						if ( $origConfModules{$name}{installed} eq 'yes' ) {
							$version = $localConfModules{$name}{version};
							$hwid = $localConfModules{$name}{hwid};
							$installed = $localConfModules{$name}{installed};
						} else {
							$version = $origConfModules{$name}{version};
							$hwid = $origConfModules{$name}{hwid};
							$installed = $localConfModules{$name}{installed};
						}
					}
				} else {
					# no upgrade available
					$version = $origConfModules{$name}{version};
					$hwid = $origConfModules{$name}{hwid};
					$installed = $origConfModules{$name}{installed};
				}
				unless(($origConfModules{$name}{installed} eq 'no') &&
						($origConfModules{$name}{required} eq 'no')) {
					print $FH "$origConfModules{$name}{name} ".
						"$version ".
						"$installed ".
						"$origConfModules{$name}{blocked} ".
						"$origConfModules{$name}{required} ".
						"$hwid\n";
				}
			}
		}
		close $FH;
	} else {
		printLog("Err: $!", 'L0', 'L1');
		printLog("can't write to configfile $configFile $!", 'TL0');
		exit (0);
	}
}


###############################################################################
# check if config file and directory exists
# loads the config or if non existent
# creates a new directory and configfile
#
sub initConfigFile {
	# create configDir if it does not exist
	unless ( -d $configDir ) {
		mkdir($configDir, 0755);
		unless ( -d $configDir ) {
			$noConfigFile = 1;
			printLog("could not create $configDir", 'TL0');
			exit (0);
		}
	}
	# read config file
	if ( -f $configFile ) {
		$noConfigFile = 0;
		readConfigFile();
		return;
	} else {
		# create a new configFile
		printLog("no configfile present ... creating one", 'TL');
		writeConfigFile();
		return;
	}
}


###############################################################################
# searches the sysfs subdirectory for active monitor entries
# and returns them as an array
#
sub findActiveEDIDs {
	my $cards_dir = '/sys/class/drm';
	my $dir_handle;
	my @edidfile;
	my $enabledFileContent;
	my $statusFileContent;

	my $edidTrigger = 0;

	if ( !opendir ($dir_handle, $cards_dir)) {
		printLog("Err: $!", 'L1');
		printLog("unable to open $cards_dir: $!", 'L1');
		return @edidfile;
	}
	my @FILES = grep { $_ ne '.' && $_ ne '..' } readdir($dir_handle);
	foreach my $file (@FILES) {
		my $path = "$cards_dir/$file";
		if ( -d $path ) {
			my $enabledFile = "$path/enabled";
			if ( -e $enabledFile ) {
				open(my $fh1, '<', $enabledFile);
				$enabledFileContent = <$fh1>;
				close($fh1);
				if ($enabledFileContent =~ /enabled/) {
					my $statusFile = "$path/status";
					if ( -e $statusFile ) {
						if (!-e $file) {
							return (0);
						}
						open(my $fh2, '<', $statusFile);
						$statusFileContent = <$fh2>;
						close($fh2);
						if ($statusFileContent =~ /connected/) {
							push @edidfile, "$path/edid";
							$edidTrigger = 1;
						}
					}
				}
			} else {
				printLog("file $enabledFile not found", 'L2');
			}
		}
	}
	if (! $edidTrigger ) {
		printLog('no enabled and active edid files found!', 'L1');
	}
	return @edidfile;
}


###############################################################################
# gets valid edid files
# converts edid data into an array of hash references to origConfModules
#
sub getEDIDData {
	my @edidFiles = findActiveEDIDs();
	my @edidRefs;
	my @edidInfo;
	my $FH;
	my $fileContent;
	foreach ( @edidFiles ) {
		if ( (-e $_) && open($FH, '<', $_) ) {
			$fileContent = do { local $/; <$FH> };
			close $FH;
			push @edidRefs, parse_edid($fileContent);
		} else {
			printLog("Err: $!", 'L1');
			printLog("could not open file $_ $!", 'L1');
		}
	}
	# returns array of hash references to module
	return @edidRefs;
}



###############################################################################
# returns 1 if the display described by a string is connected, otherwise 0
# the requesting string is build by appending the following data as returned by
# edid-decode
# manufacturer_name Model product_code Serial Number serial_number
# the values from manufacturer_name, product_code and serial_number are
# extracted by Parse::EDID
#
sub isDisplayPresent {
	my $edidSearchString = shift;
	my @edidRefs = getEDIDData();
	my $edidInfo;
	if (@edidRefs == 0) {
		return (0);
	} else {
		foreach my $edidData (@edidRefs) {
			$edidInfo = $$edidData{manufacturer_name}." Model ".$$edidData{product_code}." Serial Number ".$$edidData{serial_number};
			if ($edidInfo =~ /$edidSearchString/) {
				return (1);
			}
		}
	}
	printLog("edid string not found", 'L1');
	return (0);
}




###############################################################################
# print status from all modules in a nice formated output
# uses the data from the local configuration file if available
# else it checks the hardware
#
# used pattern:
# installed and new module version equal (no update)
# installed	req. old	req. new	notes
# no		no			no			ign
# yes		no			no			installed but not required!
# no		yes			no			ign
# yes		yes			no			ign
# no		no			yes			ign
# yes		no			yes			ign
# no		yes			yes			not inst. but required
# yes		yes			yes			inst. and req.
#
# installed and new module version not equal (update?)
# to be done in next version
#
sub listStatus {
	my @arr = ( ['Name', 'Version', 'Installed', 'Blocked', 'Required'] );
	my $module;
	my $noneRequired = 1;
	my $printIt = 0;
	my $upgradeAvailable = '';

	foreach $module (sort keys %localConfModules) {
		if($origConfModules{$module}{upgrade} eq 'yes') {
			$upgradeAvailable = ' - upgrade available';
		} else {
			$upgradeAvailable = '';
		}
		if (($localConfModules{$module}{installed} eq 'yes') &&
			($localConfModules{$module}{required} eq 'no') &&
			($origConfModules{$module}{required} eq 'no')) {
			# module is installed but should not be
			$printIt = 1;
			push(@arr,
				["$localConfModules{$module}{name}",
				"$localConfModules{$module}{version}",
				"$localConfModules{$module}{installed}",
				"$localConfModules{$module}{blocked}",
				"$localConfModules{$module}{required}"]);
		}
		# required, installed and not removed
		if (($localConfModules{$module}{required} eq 'yes') ||	($localConfModules{$module}{required} eq 'prerequisite')) {
			$noneRequired = 0;
			$printIt = 1;
			push(@arr,
				["$localConfModules{$module}{name}",
				"$localConfModules{$module}{version}",
				"$localConfModules{$module}{installed}",
				"$localConfModules{$module}{blocked}",
				"$localConfModules{$module}{required}$upgradeAvailable"]);
		}
	}
	if ($printIt) {
		print "Selected installation mode: $mode\n";
		print "Only showing fixes that are available for this hardware\n";
		for my $row (@arr) {
			format STDOUT =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< @<<<<<<< @<<<<<<<<< @<<<<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<<
			@$row
.
			write;
		}
	}
	if ($noneRequired) {
		print "No fixes available for this system\n";
	}
}


###############################################################################
# copies values from local configuration module into new configuration module
# copies always 'blocked'
#
sub transferConfigValues {
	my $name;
	foreach $name (sort keys %localConfModules) {
		# always copy blocked status
		$origConfModules{$name}{blocked} = $localConfModules{$name}{blocked};
		if (newVersion($name) || newHwid($name)) {
			# new version or new hwid => upgrade necessary
			$origConfModules{$name}{upgrade} = 'yes';
			$origConfModules{$name}{upgraded} = 'no';
		} else {
			$origConfModules{$name}{installed} = $localConfModules{$name}{installed};
			$origConfModules{$name}{upgrade} = 'no';
			$origConfModules{$name}{upgraded} = 'no';
		}
	}
}



###############################################################################
# returns 0 if no new version
# returns 1 if new version
sub newVersion {
	my $module = shift;
	if ($localConfModules{$module}{version} < $origConfModules{$module}{version}) {
		return (1);
	} else {
		return (0);
	}
}


###############################################################################
# returns 0 if no new hwid
# returns 1 if new hwid
sub newHwid {
	my $module = shift;
	if ($localConfModules{$module}{hwid} < $origConfModules{$module}{hwid}) {
		return (1);
	} else {
		return (0);
	}
}



###############################################################################
# adds module hash to list of configured modules with status
#
sub addToConfiguredModules {
	my $module = shift;
	my $status = shift;
	$configuredModules{$module} = $status;
	if ($status =~ /failed/) {
		printLog("failed to install $origConfModules{$module}{name}", 'L0');
	} elsif ($status =~ /success/) {
		printLog("succesfully installed $origConfModules{$module}{name}", 'L0');
	} elsif ($status =~ /removed/) {
		if (($mode ne 'DONT_CONFIGURE') || ($mode ne 'UPDATES_ONLY')) {
			printLog("succesfully removed $origConfModules{$module}{name}", 'L0');
			print "The module $origConfModules{$module}{name} has been removed. Please block it with:\n";
			print "\$ sudo tomte block $origConfModules{$module}{name}\n";
			print "unless you set the mode DONT_CONFIGURE or UPDATE_ONLY\n";
			print "or tomte will reinstall it again at the next start\n";
		}
	} elsif ($status =~ /remove failed/) {
		printLog("failed to remove $origConfModules{$module}{name}", 'L0');
	} elsif ($status =~ /nothingToDo/) {
		printLog("nothing to do for $origConfModules{$module}{name}", 'L0');
	}
}



###############################################################################
# parses sub name from %origConfModules list from given module parameter name
# returns the name of the module vector found
# returns an empty string if not found
#
sub getSubName {
	my $moduleName = shift;
	my $module;
	foreach $module ( keys %origConfModules ) {
		if (defined $origConfModules{$module}{name}) {
			if ( $moduleName eq $origConfModules{$module}{name} ) {
				return $module;
			}
		}
	}
	# return empty string if module is not found
	return "";
}


###############################################################################
# returns the shortname of module if the name is a valid module name
# returns '' if not
#
sub validModuleName {
	my $moduleName = shift;
	my $module;
	foreach $module ( keys %origConfModules ) {
		if (defined $origConfModules{$module}{name}) {
			if ($origConfModules{$module}{name} eq $moduleName) {
				return $module;
			}
		}
	}
	return '';
}



###############################################################################
# configures all modules
# if not blocked, required and not installed
#
# u=upgrade
# c=configure
# R=remove
# .=nothing
#
# installed blocked		required	newversion	newhwid
# tomte.cfg	tomte.cfg	check		origConfig	origConfig
# yes		yes			yes			yes			yes		.
# yes		yes			yes			yes			no		.
# yes		yes			yes			no			yes		.
# yes		yes			yes			no			no		.
# yes		yes			no			yes			yes		.
# yes		yes			no			yes			no		.
# yes		yes			no			no			yes		.
# yes		yes			no			no			no		.
# yes		no			yes			yes			yes		u
# yes		no			yes			yes			no		u
# yes		no			yes			no			yes		u
# yes		no			yes			no			no		.
# yes		no			no			yes			yes		R
# yes		no			no			yes			no		R
# yes		no			no			no			yes		R
# yes		no			no			no			no		R
# no		yes			yes			yes			yes		.
# no		yes			yes			yes			no		.
# mo		yes			yes			no			yes		.
# no		yes			yes			no			no		.
# no		yes			no			yes			yes		.
# no		yes			no			yes			no		.
# no		yes			no			no			yes		.
# no		yes			no			no			no		.
# no		no			yes			yes			yes		C
# no		no			yes			yes			no		C
# no		no			yes			no			yes		C
# no		no			yes			no			no		C
# no		no			no			yes			yes		.
# no		no			no			yes			no		.
# no		no			no			no			yes		.
# no		no			no			no			no		.



sub configureAllModules {
	my $module;
	my $exit_status;
	foreach $module (keys %origConfModules) {
		# prerequisites are automatically ommited (required=prerequisite)
		# they are done in prerequisite and postrequisite subroutines
		if ($origConfModules{$module}{order} ne 'first') {
			if ($origConfModules{$module}{required} eq 'yes') {
				if ($origConfModules{$module}{reconfigure} eq 'always') {
					# reconfigure modules with 'always' every single time
					reconfigureSingleModule($origConfModules{$module}{name});
				} else {
					configureSingleModule($origConfModules{$module}{name});
				}
			} elsif (($origConfModules{$module}{required} eq 'no') &&
				(($localConfModules{$module}{installed} eq 'yes') ||
				($localConfModules{$module}{installed} eq 'failed'))) {
				removeSingleModule($origConfModules{$module}{name});
			}
		}
	}
}



###############################################################################
# configures a single module
# if not blocked, required and not installed
#
sub configureSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);
	if ($module eq "") {
		printLog("wrong module name", 'TL');
		return;
	}

	# grub file should always be checked for correct entries if there
	# is a fix available for this system
	if ( (($localConfModules{$module}{installed} eq 'no') ||
		($localConfModules{$module}{installed} eq 'failed') ||
	   	($origConfModules{$module}{postconf} eq 'updateGrub')) &&
		$localConfModules{$module}{blocked} eq 'no' &&
		$origConfModules{$module}{required} eq 'yes') {
		printLog("configure module: $module", 'L1');
		configureModule($module);
	} elsif ( $localConfModules{$module}{installed} eq 'yes' &&
		$localConfModules{$module}{blocked} eq 'no' &&
		$origConfModules{$module}{required} eq 'yes' &&
		$origConfModules{$module}{upgrade} eq 'yes' ) {
		# upgrade if new version or hwid
		printLog("upgrade module: $module", 'L1');
		upgradeModule($module);
	} elsif ( $localConfModules{$module}{installed} eq 'yes' ) {
		$configuredModules{$module} = 'nothingToDo';
	}
	if (($localConfModules{$module}{blocked} eq 'yes') &&
		($origConfModules{$module}{required} ne 'prerequisite') &&
   		($mode ne 'DONT_CONFIGURE') &&
		($mode ne 'UPDATES_ONLY')) {
		print "Module $moduleName cannot be installed/removed/updated because:\n";
		print "- it is blocked (maybe use 'unblock')\n";
	}
}



###############################################################################
# checks if the conditions to remove a module are met
#
sub removeSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);

	if ($module eq "") {
		printLog("wrong module name", 'TL');
		return;
	}

	if ($localConfModules{$module}{blocked} eq 'no') {
		printLog("removing module $moduleName", 'TL');
		removeModule($module);
	}	

	if ( $localConfModules{$module}{blocked} eq 'yes' ) {
		print "Module $moduleName cannot be removed because:\n";
		print "- it is blocked (maybe use 'unblock')\n";
	}
}



###############################################################################
# reconfigures all modules if not blocked and if required even if it is
# already installed
#
sub reconfigureAllModules {
	my $module;
	my $exit_status;
	foreach $module (keys %origConfModules) {
		if ($origConfModules{$module}{order} ne 'first') {
			if ($origConfModules{$module}{required} eq 'yes') {
				reconfigureSingleModule($origConfModules{$module}{name});
			} elsif (($origConfModules{$module}{required} eq 'no') &&
					(($localConfModules{$module}{installed} eq 'yes') || ($localConfModules{$module}{installed} eq 'failed'))) {
				removeModule($module);
			}
		}
	}
}



###############################################################################
# reconfigures a single module if not blocked and if required or prerequisite
# even if it is already installed
#
sub reconfigureSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);
	printLog("reconfigureSingleModule: $moduleName", 'L2');
	if ($module eq "") {
		printLog("wrong module name", 'TL');
		return;
	}

	if (($origConfModules{$module}{required} eq 'prerequisite') ||
		(($localConfModules{$module}{blocked} eq 'no') && ($origConfModules{$module}{required} eq 'yes'))) {

		if ($origConfModules{$module}{upgrade} eq 'yes') {
			printLog("upgrade module: $module", 'L1');
			upgradeModule($module);
		} else {
			printLog("configure module: $module", 'L1');
			configureModule($module);
		}
	} elsif ( $localConfModules{$module}{installed} eq 'yes' ) {
		$configuredModules{$module} = 'nothingToDo';
	}

	if (($localConfModules{$module}{blocked} eq 'yes') &&
		($origConfModules{$module}{required} ne 'prerequisite') &&
   		($mode ne 'DONT_CONFIGURE') &&
		($mode ne 'UPDATES_ONLY')) {
		print "Module: $moduleName cannot be installed because:\n";
		print "- it is blocked (maybe use 'unblock')\n";
	}

	if (($origConfModules{$module}{required} eq 'no') &&
		($configuredModules{$module} ne 'remove failed') &&
		($configuredModules{$module} ne 'removed')) {
		print "Module: $moduleName cannot be installed because:\n";
		print "- it is not required by this system (this is the main reason)\n";
	}
}




###############################################################################
# blocks a module
#
sub block {
	my $moduleName = shift;
	my $module = getSubName($moduleName);
	printLog("block module: >$module<", 'L2');
	if ($module eq '') {
		print "Module $moduleName does not exist\n";
		return;
	}
	if ($origConfModules{$module}{required} eq 'prerequisite') {
		print "Module $moduleName is a prerequisite and can't be blocked\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'yes') {
		print "Module $moduleName is already blocked\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'no') {
		print "Blocking module $moduleName\n";
		print "$moduleName will not be upgraded or reinstalled if removed\n";
		$origConfModules{$module}{blocked} = 'yes';
		printLog("blocking module $moduleName", 'L1');
		return;
	}
}

###############################################################################
# unblocks a module
#
sub unblock {
	my $moduleName = shift;
	my $module = getSubName($moduleName);
	printLog("unblock module: >$module<", 'L2');
	if ($module eq '') {
		print "Module $moduleName does not exist\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'no') {
		print "Module $moduleName is not blocked\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'yes') {
		print "Unblocking module $moduleName\n";
		$origConfModules{$module}{blocked} = 'no';
		printLog("unblocking module $moduleName", 'L1');
		return;
	}
}


###############################################################################
# blocks all modules
#
sub blockAllModules {
	my $module;
	foreach $module (keys %origConfModules) {
		if (($origConfModules{$module}{required} eq 'yes') &&
			($origConfModules{$module}{blocked} ne 'yes') &&
			($origConfModules{$module}{required} ne 'prerequisite')) {
			$origConfModules{$module}{blocked} = 'yes';
			printLog("blocking module $origConfModules{$module}{name}", 'TL0');
		}
	}
}



###############################################################################
# unblocks all modules
#
sub unblockAllModules {
	my $module;
	foreach $module (keys %origConfModules) {
		if (($origConfModules{$module}{required} eq 'yes') &&
			($origConfModules{$module}{blocked} eq 'yes')) {
			$origConfModules{$module}{blocked} = 'no';
			printLog("unblocking module $origConfModules{$module}{name}", 'TL0');
		}
	}
}




###############################################################################
# set configuration mode setMode('mode')
# AUTOMATIC: install/remove/update everything automatically
# UPDATES_ONLY: only update installed modules
# DONT_CONFIGURE: do not configure anything
#
sub setMode {
	my $requestedMode = shift;
	my $key;

	$mode = checkMode();
	if ($mode eq $requestedMode) {
		printLog("Requested mode '$requestedMode' is already set", 'TL0');
	} else {
		foreach $key (keys %modeFile) {
			if ($key eq $requestedMode) {
				createFile($modeFile{$requestedMode}, '', 0);
				printLog("creating modefile: $modeFile{$requestedMode} for $requestedMode", 'TL0');
			} elsif (-e $modeFile{$key}) {
				unlink($modeFile{$key});
				printLog("removing superfluous modefile: $modeFile{$key}", 'TL2');
			}
		}
	}
}



sub checkMode {
	my $tmpMode;
	my $countModes = 0;
	if (-e $modeFile{AUTOMATIC}) {
		++$countModes;
		$mode = 'AUTOMATIC';
	}
	if (-e $modeFile{UPDATES_ONLY}) {
		++$countModes;
		$mode = 'UPDATES_ONLY';
	}
	if (-e $modeFile{DONT_CONFIGURE}) {
		++$countModes;
		$mode = 'DONT_CONFIGURE';
	}
	if ($countModes == 0) {
		$mode = 'AUTOMATIC';
		printLog('No mode setting found, assuming AUTOMATIC', 'L2');
		$mode = 'AUTOMATIC';
	}
	if ($countModes == 1) {
		printLog("Found mode setting $mode", 'L2');
	}
	if ($countModes > 1) {
		printLog("More then one mode setting found, assuming $mode", 'L2');
	}
	return $mode;
}



###############################################################################
# checks if the operation is allowed in this mode/command/module
# usage: checkModePermision(install|remove|update, MODULE)
# returns 0 if not and 1 if allowed
sub checkModePermission {
	my ($operation, $module) = (@_);
	# this is a double check, just in case ...

	if ($origConfModules{$module}{required} eq 'prerequisite') {
		printLog("module is prerequisite", 'L2');
		# always permit if it is a prerequisite
		return (1);
	}
	# when FAI assume yes on all
	if ($argValue{command} eq 'FAI') {
		return (1);
	}
	# when Live ISO or FAI assume yes on all
	if ($LiveISO || $FAI) {
		return (1);
	}
	if ($argValue{command} eq 'configure') {
		if ($argValue{module} eq 'all') {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (0);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
		} else {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
		}
	}
	if ($argValue{command} eq "reconfigure") {
		if ($argValue{module} eq 'all') {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (0);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
		} else {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
		}
	}
	if ($argValue{command} eq "remove") {
		if ($argValue{module} eq 'all') {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (0);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (0);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
		} else {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
		}
	}
	# just to be safe return 0
	return (0);
}



###############################################################################
# configures a module, does no checks
#
sub configureModule {
	my $module = shift;
	my $permission = checkModePermission('install', $module);
	printLog("configure module: $module permission: $permission", 'L2');
	if ($permission) {
		$module->($module, 'install');
	}
}


###############################################################################
# remove a module, does no checks
#
sub removeModule {
	my $module = shift;
	my $permission = checkModePermission('remove', $module);
	printLog("remove module: $module permission: $permission", 'L2');
	if ($permission) {
		$module->($module, 'remove');
	}
}



###############################################################################
# configures a module, does no checks
#
sub upgradeModule {
	my $module = shift;
	my $permission = checkModePermission('upgrade', $module);
	printLog("upgrade module: $module permission: $permission", 'L2');
	if ($permission) {
		$module->($module, 'upgrade');
	}
}



###############################################################################
# remove warning message and confirmation
# removeWarningMessage('message')
# returns 1 if answered with y or Y
# returns 0 otherwise
# checks if in a valid tty => returns 1
#
sub removeWarningMessage {
	my $message = shift;
	my $answer;
	if (!isatty()) {
		return (1);
	}
	if ($message ne '') {
		print "$message";
	}
	print "Are you sure you want to remove this module? (y/n) ";
	chomp($answer = <STDIN>);
	if (($answer eq 'y') || ($answer eq 'Y')) {
		return (1);
	} else {
		return (0);
	}
}




###############################################################################
# checks if we are in a terminal
# returns 1 if yes
# returns 0 if not
#
sub isatty {
	no autodie;
	my $ttyDevice = '/dev/tty';
	if (!-e $ttyDevice) {
		return (0);
	}
	state $isatty = open(my $tty, '+<', $ttyDevice);
	return $isatty;
}




###############################################################################
# starts system programs (if necessary) to activate the module changes
#
sub postConfigure {
	my $sysProgram;
	my $exitStatus;
	my $postConfTrigger = 0;
	my $output;
	my $command;
	printLog("initializing post-configuration");
	foreach $sysProgram (keys %postConfProgram) {
		if ($postConfProgram{$sysProgram}{trigger} == 1 ) {
			printLog("starting $sysProgram", 'L1');
			$command = $postConfProgram{$sysProgram}{command}.' 2>&1';
			$output = `$command`;
			$exitStatus = $?;
			if ($exitStatus == 0) {
				printLog("success: $postConfProgram{$sysProgram}{command}", 'L1');
				postSetModulesState($sysProgram, "success");
				$restartSystem = 1;
			} else {
				$postConfTrigger = 1;
				printLog("failed: $postConfProgram{$sysProgram}{command}", 'L0');
				printLog("returned error code: $exitStatus", 'L0');
				postSetModulesState($sysProgram, "failed");
			}
		}
	}
	if ($postConfTrigger == 1) {
		startTomteDelayed();
	}
}




###############################################################################
# starts the tuxedo-tomte service for delayed configuration
#
sub startTomteDelayed {
	my $retVal;
	$restartSystem = 0;
	my $triesValue;
	printLog("start later again: $startLaterAgain", 'L2');
	if ($startLaterAgain != 1) {
		$triesValue = tries($triesLimit);
		if (! $triesValue) {
			printLog("repeat limit reached, program will not start again, tries: $triesValue", 'L2');
			$startLaterAgain = 1;
			if ($restartSystem) {
				messageDesktop('Restart required', 'Please restart the system for the changes to take effect. Tomte could not install all the fixes and will try again the next time it is activated', 2, 'dialog-warning');
				print "\nPlease restart the system for the changes to take effect, not all the fixes could be installed\n";
			} else {
				messageDesktop('Tomte ready', 'Tomte could not install all the fixes and will try again the next time it is activated', 2, 'dialog-warning');
				print "\nNot all the fixes could be installed\n";
			}
			return (1);
		} else {
			printLog("program will start again, tries: $triesValue, trieslimit: $triesLimit", 'L2');
		}
	}
	if ($startLaterAgain == 0) {
		$startLaterAgain = 1;
		$retVal = system("systemd-run --on-active=1min tuxedo-tomte configure all >/dev/null 2>&1");
		printLog("starting \"systemd-run tuxedo-tomte configure all\" for delayed configuration", 'L0');
		printLog("ret value: $retVal", 'L0');
	}
	return (0);
}



###############################################################################
# sets all modules dependant of some system program to work to status failed
#
sub postSetModulesState {
	my $sysProgram = shift;
	my $status = shift;
	my $module;
	$postConfProgram{$sysProgram}{status} = $status;
	foreach $module (keys %configuredModules) {
		$configuredModules{$module}{status} = $status;
	}
}


###############################################################################
# lists which modules and system programs where installed, configured
# or executed correctly and which not
#
sub listSuccess {
	my $confProgram;
	my $confModule;
	my @failedPrograms;
	my @failedModules;
	my @successModules;
	my @nothingToDoModules;
	my @removedModules;
	my $successOrFailed = 0;

	foreach $confProgram (keys %postConfProgram) {
		if ($postConfProgram{$confProgram}{status} eq "failed") {
			$successOrFailed = 1;
			push(@failedPrograms, $postConfProgram{$confProgram}{command});
		}
	}
	foreach $confModule (keys %configuredModules) {
		if ($configuredModules{$confModule} eq "failed") {
			$successOrFailed = 1;
			push(@failedModules, $confModule);
		} elsif ($configuredModules{$confModule} eq "success") {
			$successOrFailed = 1;
			push(@successModules, $confModule);
		} elsif ($configuredModules{$confModule} eq "nothingToDo") {
			push(@nothingToDoModules, $confModule);
		} elsif ($configuredModules{$confModule} eq "removed") {
			push(@removedModules, $confModule);
		}
	}
	if (@successModules) {
		print "\nThe following modules have been installed successfully:\n";
		printNameDescriptionModules(@successModules);
	}
	if (@failedModules) {
		print "\nThe following modules have failed to be installed:\n";
		if (triesAlreadyDone() <= $triesLimit) {
			if ($FAI) {
				print "Tomte will try to install them after reboot\n";
			} else {
				print "Tomte will try to install them again in a few minutes\n";
			}
		}
		printNameDescriptionModules(@failedModules);
	}
	if (@nothingToDoModules) {
		print "\nNothing was done for the following modules:\n";
		printNameDescriptionModules(@nothingToDoModules);
	}
	if (@failedPrograms) {
		print "\nThe following post installation programs have failed:\n";
		printNameDescriptionPrograms(@failedPrograms);
	}
	if (@removedModules) {
		print "\nThe following modules have been removed:\n";
		printNameDescriptionModules(@removedModules);
	}
	if (! $successOrFailed) {
		print "\nNothing to do in post configuration\n";
	}
	if ($restartSystem == 1) {
		messageDesktop('Restart required', 'Please restart the system for the changes to take effect.', 2, 'dialog-warning');
		print "\nPlease restart the system for the changes to take effect\n";
	} elsif ( configuredModulesExceptDefault(@successModules) ) {
		messageDesktop('TUXEDO Tomte ready', 'TUXEDO Tomte finished applying all the required fixes available for this system.', 1, 'dialog-information');
	}
}



###############################################################################
# returns 1 if any modules except defined ones were configured
# returns 0 if otherwise
#
sub configuredModulesExceptDefault {
	my @modulesList = @_;
	my @defaultModules = ( 'tuxedorepos', 'tuxedomirrors' );
	foreach ( @defaultModules ) {
		for my $index (reverse 0..$#modulesList) {
			if ($modulesList[$index] =~ /$_/) {
				splice(@modulesList, $index, 1, ());
			}
		}
	}
	if ((scalar(@modulesList) > 0) || ($longInstall == 1)) {
		return (1);
	}
	return (0);
}



###############################################################################
# print name and description from modules given as array
#
sub printNameDescriptionModules {
	my @elements = @_;
	my $element;
	foreach $element (@elements) {
		print "- $origConfModules{$element}{name}: $origConfModules{$element}{description}\n";
	}
}


###############################################################################
# print name and description for programs given as array
#
sub printNameDescriptionPrograms {
	my @elements = @_;
	my $element;
	foreach $element (@elements) {
		print "- $element: $postConfProgram{$element}{description}\n";
	}
}


###############################################################################
# show description of module
#
sub moduleDescription {
	my $moduleName = $argValue{module};
	my $module;
	if ($moduleName) {
		$module = getSubName($moduleName);
		if ( $module ne "" ) {
	    print "$origConfModules{$module}{description}\n";
		} else {
			print "module: $moduleName is not in the modules list\n";
		}
    } else {
		print "Missing module name\n";
	}
}



###############################################################################
# show all modules
#
sub modulesList() {
	my $module;
	foreach $module (keys %origConfModules) {
		print "$origConfModules{$module}{name}\n";
	}
}



###############################################################################
# limits number of tries Tomte will do to accomplish some task
# returns 0 if limit has been reached
# returns 1 if limit is not reached
#
sub tries() {
	my $limit = shift;
	printLog("tries: given limit: $limit", 'L2');
	if (-e $triesFile) {
		my $triesDone = triesAlreadyDone();
		printLog("repeat number $triesDone of $limit", 'L0');
		if ( $triesDone < $limit ) {
			printLog("rising tries, triesDone below limit", 'L2');
			writeFile($triesDone+1, $triesFile);
			return (1);
		} else {
			printLog("limit tries done reached", 'L2');
			printLog('deleting triesFile', 'L2');
			unlink($triesFile);
			return (0);
		}
	} else {
		printLog('creating triesFile', 'L2');
		writeFile('1', $triesFile);
	}
	return (1);
}




###############################################################################
# returns how many times Tomte got repeated
#
sub triesAlreadyDone() {
	if (-e $triesFile) {
		return (readFileReturnLine($triesFile)+0);
	} else {
		return (0);
	}
}



###############################################################################
# text to print for help
#
my $USAGE =<<USAGE;
tuxedo-tomte <COMMAND> [NAME...]
tomte <COMMAND> [NAME...]
  list                           List all installable modules with detailed status
  modules                        List all available modules
  description MODULE             Shows the module description
  configure MODULE ...|all       Configure an unconfigured module
  reconfigure MODULE...|all      Reconfigure a configured module
  remove MODULE                  Remove a module from the system
  block MODULE ...|all           Blocks one or all modules
  unblock MODULE ... |all        Unblocks one or all modules
  AUTOMATIC                      Activates automatic configuration
  UPDATES_ONLY                   Only updates will be installed automatically
  DONT_CONFIGURE                 Stops all automatic configuration
  help                           Prints this message
  
  more details can be found in the man page
USAGE



###############################################################################
# prints help
#
sub help {
	print "$USAGE\n";
	exit 0;
}


###############################################################################
# checks if root and returns 1 if yes, otherwise 0
#
sub isRoot {
	# check if root
	if( $> != 0 ) {
		return (0);
	}
	return (1);
}


###############################################################################
# checks system requirements, loads configfile
#
sub prepareValues {
	checkRequirements();
	initConfigFile();
	transferConfigValues();
}


###############################################################################
# checks if this is a TUXEDO device
#
sub tuxedoDevice {
	if ($boardname =~ /P65_P67RGRERA/) {
		return (1);
	}
	if ($boardvendor =~ /TUXEDO/) {
		return (1);
	}
	if ($sysvendor =~ /TUXEDO/) {
		return (1);
	}
	if ($boardname =~ /LAPQC71[AB]/) {
		return (1);
	}
	return (0);
}





###############################################################################
###############################################################################
# MAIN PROGRAM

if (!tuxedoDevice()) {
	print 'It seems that this is not a TUXEDO device. Please contact us if this is a mistake';
	exit (0);
}

readOSData();

if (!isOSSupported()) {
	exit (0);
}

# define for each argvalues procedures
# modify $USAGE if any modifications are made here

if (@ARGV != 0) {
	my %options;
	@options{"configure", "reconfigure", "remove", "block", "unblock", "update"} = ();

	if (exists $options{$argValue{command}} && (! isRoot() )) {
		print "You must have root access to use this option\n";
		exit (0);
	}

	# check whether it is a LiveISO installation
	# checks if directory /fll exists
	if ((-d '/fll') && isTextInFile('/proc/cmdline', 'fll')) {
		if (-e $tomteFinishedFile) {
			unlink($tomteFinishedFile);
		}
		print "Starting tuxedo-tomte in LiveISO mode\n".
				"This should not be used in a normal situation\n".
				"only when installing a new system with LiveISO\n";
		$LiveISO = 1;
		initLogging();
		printLog("starting Tomte in LiveISO mode", 'L0');
		setMode('AUTOMATIC');
		prepareValues();
		prerequisites();
		configureAllModules();
		postConfigure();
		listSuccess();
		writeConfigFile();
		createFile($tomteFinishedFile, 'finished', 0);
	}

	# list
	if ($argValue{command} eq "list") {
		checkMode();
		if (!-e $configFile) {
			print "no config file present yet, please use 'sudo tomte list' to initialize one\n";
		} else {
			prepareValues();
		}
		listStatus();

	# modules
	} elsif ($argValue{command} eq "modules") {
		modulesList();

	# printcompletefixeslist
	} elsif ($argValue{command} eq "printcompletefixeslist") {
		printTuxedoDevices();

	# description
	} elsif ($argValue{command} eq "description") {
		moduleDescription();

	# help
	} elsif ($argValue{command} eq "help") {
		help();

	# FAI
	} elsif ($argValue{command} eq "FAI") {
		print "Starting tuxedo-tomte in FAI mode\n".
				"This should not be used in a normal situation\n".
				"only when installing a new system with FAI\n";
		$FAI = 1;
		initLogging();
		setMode('AUTOMATIC');
		prepareValues();
		prerequisitesFAI();
		configureAllModules();
		postrequisitesFAI();
		postConfigure();
		listSuccess();
		writeConfigFile();

	# configure
	} elsif ($argValue{command} eq "configure") {
		# check if there is a second argument
		if ($argValue{module} ne '') {
			initLogging();
			checkMode();
			prepareValues();
			prerequisites();
			if ($argValue{module} eq "all") {
				lockPackageManagement();
				if ($mode eq 'DONT_CONFIGURE') {
					printLog("Mode DONT_CONFIGURE is set", 'TL0');
					printLog("only prerequisite modules will be installed", 'TL0');
				}
				if (-e $tomteFinishedFile) {
					unlink($tomteFinishedFile);
				}
				configureAllModules();
				postConfigure();
				listSuccess();
				writeConfigFile();
				if(!(-e $tomteFinishedFile) && ($startLaterAgain == 0)) {
					createFile($tomteFinishedFile, 'finished', 0);
				}
			} elsif (validModuleName($argValue{module}) ne '') {
				lockPackageManagement();
				if ($mode eq 'DONT_CONFIGURE') {
					printLog("Mode DONT_CONFIGURE is set", 'TL0');
					printLog("only prerequisite modules will be installed", 'TL0');
				}
				if (-e $tomteFinishedFile) {
					unlink($tomteFinishedFile);
				}
				configureSingleModule($argValue{module});
				postConfigure();
				listSuccess();
				writeConfigFile();
				if(!(-e $tomteFinishedFile) && ($startLaterAgain == 0)) {
					createFile($tomteFinishedFile, 'finished', 0);
				}
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name or \"all\" missing\n";
		}
		printLog('Tomte finished', 'L1');

	# remove
	} elsif ($argValue{command} eq "remove") {
		if ($argValue{module} ne '') {
			if (validModuleName($argValue{module}) ne '') {
				lockPackageManagement();
				if (-e $tomteFinishedFile) {
					unlink($tomteFinishedFile);
				}
				initLogging();
				checkMode();
				prepareValues();
				prerequisites();
				removeSingleModule($argValue{module});
				postConfigure();
				listSuccess();
				writeConfigFile();
				if(!(-e $tomteFinishedFile) && ($startLaterAgain == 0)) {
					createFile($tomteFinishedFile, 'finished', 0);
				}
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name or \"all\" missing\n";
		}
		printLog('Tomte finished', 'L1');

	# reconfigure
	} elsif ($argValue{command} eq "reconfigure") {
		# reconfigure interrupts repeated execution
		if (-e $triesFile) {
			printLog('delete triesFile', 'L2');
			unlink($triesFile);
		}
		if ($argValue{module} ne '') {
			initLogging();
			checkMode();
			prepareValues();
			prerequisites();
			if ($argValue{module} eq "all") {
				lockPackageManagement();
				if ($mode eq 'DONT_CONFIGURE') {
					printLog("DONT_CONFIGURE is set", 'TL0');
					printLog("only prerequisite modules will be installed", 'TL0');
				}
				if (-e $tomteFinishedFile) {
					unlink($tomteFinishedFile);
				}
				reconfigureAllModules();
				postConfigure();
				listSuccess();
				writeConfigFile();
				if(!(-e $tomteFinishedFile) && ($startLaterAgain == 0)) {
					createFile($tomteFinishedFile, 'finished', 0);
				}
			} elsif (validModuleName($argValue{module}) ne '') {
				lockPackageManagement();
				if ($mode eq 'DONT_CONFIGURE') {
					printLog("DONT_CONFIGURE is set", 'TL0');
					printLog("only prerequisite modules will be installed", 'TL0');
				}
				if (-e $tomteFinishedFile) {
					unlink($tomteFinishedFile);
				}
				reconfigureSingleModule($argValue{module});
				postConfigure();
				listSuccess();
				writeConfigFile();
				if(!(-e $tomteFinishedFile) && ($startLaterAgain == 0)) {
					createFile($tomteFinishedFile, 'finished', 0);
				}
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name or \"all\" missing\n";
		}
		printLog('Tomte finished', 'L1');

	# blocking/unblocking should work in any mode
	# block
	} elsif ($argValue{command} eq "block") {
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			if ($argValue{module} eq 'all') {
				blockAllModules();
				writeConfigFile();
				printLog('Tomte finished', 'L1');
			} elsif (validModuleName($argValue{module}) ne '') {
				block($argValue{module});
				writeConfigFile();
				printLog('Tomte finished', 'L1');
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name missing\n";
		}

	# unblock
	} elsif ($argValue{command} eq "unblock") {
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			if ($argValue{module} eq 'all') {
				unblockAllModules();
				writeConfigFile();
				printLog('Tomte finished', 'L1');
			} elsif (validModuleName($argValue{module}) ne '') {
				unblock($argValue{module});
				writeConfigFile();
				printLog('Tomte finished', 'L1');
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name missing\n";
		}

	# modes
	} elsif (($argValue{command} eq "DONT_CONFIGURE") ||
			($argValue{command} eq "AUTOMATIC") ||
			($argValue{command} eq "UPDATES_ONLY")) {
		initLogging();
		setMode($argValue{command});
		prepareValues();
		printLog('Tomte finished', 'L0');
	} else {
		print "Unknown command: $argValue{command}\n";
		help();
	}
} else {
	help();
}

# interrupt repeated delayed execution if not necessary anymore
if (($startLaterAgain == 0) &&
	($argValue{command} eq 'configure') &&
	($argValue{command} eq 'reconfigure')) {
	if (-e $triesFile) {
		if (-w $triesFile) {
			printLog('deleting triesFile', 'L2');
			unlink($triesFile);
		}
	}
}
